\section{High Performance Computing}

High performance computing (from here on, HPC) is a field of computing, where the main objective is performance, often measured in floating point operations per second (FLOPS). The term HPC is typically associated with supercomputers and large distributed systems. 

HPC systems are rarely used by the \enquote{average Joe}, but more so by scientists and engineers who need to perform computations on very large data sets, model reality with a high level detail or calculate very large equations. It is this type of computing that TLDR, will focus on.


\subsection{Supercomputers and Distributed Systems}

Nearly all HPC systems are either supercomputers or distributed systems. Contemporary supercomputers are getting more and more powerful, with the current world leader, the Chinese Tianhe-2, having a theoretical peak performance of almost 55 petaFLOPS \cite{top500}.

Distributed systems are generally a large group, called a \enquote{cluster}, consisting of computers, referred to as \enquote{nodes}. In these systems, the individual nodes might not be any more powerful than an ordinary desktop computer, but the collective processing power of the whole cluster can rival that of a supercomputer.

A simple cluster could consist of the following nodes:
\begin{description}
	\item [Head]
	The controller of the cluster. This is where the clusters interface is, and where the jobs that should be performed are first introduced to the system.
	\item [Compute]
	A generic worker. A compute node receives a job and returns the result of the computation. In a normal cluster, you would have many compute nodes.
	\item [Scheduler]
	A node with the sole purpose of sending jobs to compute nodes. A good scheduler will evenly distribute the load of jobs to the compute nodes, minimising the total computation time.
\end{description}

These systems' performance is high, mainly due to their extensive use of parallel computing. This parallelism is achieved, in the case of Tianhe-2, by using MPICH2, one of the most popular implementations of the MPI specification for message passing. This requires the programmer to consider parallelism when writing the programs.

\subsection{Current Technology}

Even though the hardware used in HPC systems evolve at a very high rate, unfortunately the same cannot be said for the programming languages used to program the systems. The programming languages almost solely used to program HPC systems are C and Fortran. At the time of writing, C is 43 years old and Fortran is 58 years old. For any technology related to software to survive this long is quite a feat, but also rather worrying considering its heavy use in HPC, which should be the milestone for efficient programming.

So why is such a critical performance-oriented field still dominated by technologies which are about half a century old? There are three very big factors in why these languages are dominant:

\begin{description}
	\item [Tried and true]
	Both C and Fortran have existed for such a long time, that both have had the time needed to mature. Every feature in the languages is almost guaranteed to be correct, as the languages have been extensively used and developed for such a long time.
	\item [Support]
	Nearly all general computational problems have been solved in C and Fortran, meaning that for almost all trivial problems, someone else has already done all the work and you can merely use their code.
	\item [Near to the metal]
	As C and Fortran are rather low level languages, there is a large amount of control in the hands of the developer. This means that there is a lot of potential for optimisation in the code.
\end{description}

These are all good features for a language, and especially being near to the metal becomes a desirable trait, when one is trying to increase the speed of the computation. 

However, this trait also provides a barrier of entry for scientists, who are not well versed in programming. This is due to multiple problems, one being a low readability and another being low writeability, both due to the languages requiring you to consider problems which solely exist in the domain of computers, and not in the domain of the problem that was originally sought to be solved. The languages are also not accommodating towards modelling of simulations, due to their imperative paradigm. It is expected that some scientists would be willing to sacrifice some of the control and speed of the C and Fortran languages, in order to better understand the code they are running, and thereby be able to write new programs faster.

In light of this, TLDR will be focused on the areas of programming where C and Fortran fall short, and there will not be as great a focus on the areas of their strengths.
