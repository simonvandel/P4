\section{Semantics}
This section describes the semmantics of the constructs in The Language Described in this Report both formally and informally. It is split into pieces each describing one construct both formally and informally.

\subsection{Formal semantics in The Language Described in this Report}
To describe the semantics formally it was decided to use small-step semantics. The alternative was big-step semantics but since the language depends heavily on non-determinism and parallelism and this is not possible to represent in big-step semantics, small-step semantic was a better choice.

The formal rules have three parts as illustrated in \cref{SS-semantics}

\begin{figure}[H]
\begin{align*}
&\inference[$RULE-NAME$]{[CONDITION]}
												{[CONCLUSSION]}
												{,[SIDE-EFFECTS]}
\end{align*}
\caption{A desription of formal small-step semantics}
\label{SS-semantics}
\end{figure}

\subsection{Actor-Environment model}
The formal semantics will also use an actor-environment model.

$a = \text{Anames} \cup \{current\} \rightharpoonup e$

$e = \text{Pnames} \rightharpoonup \mathbb{S}\text{tm} \times \text{Pnames}$

\subsection{General Constructs}
\begin{align*}
&\inference[$\text{INVOKE}$]{\Braket{S_1,e[p_1' \mapsto \Braket{S_2,p_2'}]} \Rightarrow_S \Braket{S_1',e'}}
                  {\Braket{p_1(p_2),e} \Rightarrow_S \Braket{S_1',e'}}
\\
&									{,e(p_1) = \Braket{S_1,p_1'}, e(p_2) = \Braket{S_2,p_2'}}
\end{align*}

\subsection{Arithmetic Expressions}
\newcommand{\Twedge}{\mathbin{^\wedge{}}}

\begin{align*}
&\inference[NUM]{}
                  {e \vdash n \Rightarrow_A v}
									{, \mathcal{N}(n) = v}
\\\\
&\inference[$\text{INVOKE}_A$]{\Braket{S_1,e[p_1' \mapsto \Braket{S_2,p_2'}]} \Rightarrow_A v}
                  {\Braket{p_1(p_2),e} \Rightarrow_A v}
\\									
&									{,e(p_1) = \Braket{S_1,p_1'}, e(p_2) = \Braket{S_2,p_2'}}
\\\\
&\inference[$\text{PARENS}_\text{A}$]{e \vdash a_1 \Rightarrow_A a_1'}
                       {e \vdash (a_1) \Rightarrow_A (a_1')}
&
&\inference[$\text{PARENS}_\text{V}$]{}
                       {(v) \Rightarrow_A v}
\\\\
&\inference[$\text{ADD}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash  a_1 + a_2 \Rightarrow_A a_1' + a_2}
&
&\inference[$\text{ADD}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
										{e \vdash a_2 + a_1 \Rightarrow_A a_2 + a_1'}
\\\\
&\inference[$\text{ADD}_\text{V}$]{}
                    {v_1 + v_2 \Rightarrow_A v}
										{, v_1 + v_2 = v}
\\\\
&\inference[$\text{SUB}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 - a_2 \Rightarrow_A a_1' - a_2}
&
&\inference[$\text{SUB}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 - a_1 \Rightarrow_A a_2 - a_1'}
\\\\
&\inference[$\text{SUB}_\text{V}$]{}
                    {v_1 - v_2 \Rightarrow_A v}
										{, v_1 - v_2 = v}
\end{align*}
\begin{align*}
&\inference[$\text{MULT}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                     {e \vdash a_1 * a_2 \Rightarrow_A a_1' * a_2}
&
&\inference[$\text{MULT}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                     {e \vdash a_2 * a_1 \Rightarrow_A a_2 * a_1'}
\\\\
&\inference[$\text{MULT}_\text{V}$]{}
                     {v_1 * v_2 \Rightarrow_A v}
										 {, v_1 * v_2 = v}
\\\\
&\inference[$\text{DIV}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 / a_2 \Rightarrow_A a_1' / a_2}
&
&\inference[$\text{DIV}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 / a_1 \Rightarrow_A a_2 / a_1'}
\\\\
&\inference[$\text{DIV}_\text{V}$]{}
                    {v_1 / v_2 \Rightarrow_A v}
										{, \frac{v_1}{v_2} = v}
\\\\
&\inference[$\text{MOD}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 \% a_2 \Rightarrow_A a_1' \% a_2}
&
&\inference[$\text{MOD}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 \% a_1 \Rightarrow_A a_2 \% a_1'}
\\\\
&\inference[$\text{MOD}_\text{V}$]{}
                    {v_1 \% v_2 \Rightarrow_A v}
										{, v_1 \;\; \textrm{mod} \;\; v_2 = v}
\\\\
&\inference[$\text{POW}_\text{L}$]{e \vdash a_1  \Rightarrow_A a_1'}
                    {e \vdash a_1 \Twedge a_2 \Rightarrow_A a_1' \Twedge a_2}
&
&\inference[$\text{POW}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 \Twedge a_1 \Rightarrow_A a_2 \Twedge a_1'}
\\\\
&\inference[$\text{POW}_\text{V}$]{}
                    {v_1 \Twedge v_2 \Rightarrow_A v}
										{, v_1 ^ {v_2} = v}
\\\\
&\inference[$\text{ROOT}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 \# a_2 \Rightarrow_A a_1' \# a_2}
&
&\inference[$\text{ROOT}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 \# a_1 \Rightarrow_A a_2 \# a_1'}
\\\\
&\inference[$\text{ROOT}_\text{V}$]{}
                    {v_1 \# v_2 \Rightarrow_A v}
										{, \sqrt[v_1]{v_2} = v}
\end{align*}

\subsection{Boolean Expressions}
\newcommand{\Tand}{\text{\; AND \;}}
\newcommand{\Tnot}{\text{NOT \;}}
\newcommand{\Tnand}{\text{\; NAND \;}}
\newcommand{\Tor}{\text{\; OR \;}} 
\newcommand{\Tnor}{\text{\; NOR \;}}
\newcommand{\Txor}{\text{\; XOR \;}}

\begin{align*}
&\inference[$\text{INVOKE}_{B\top}$]{\Braket{S_1,e[p_1' \mapsto \Braket{S_2,p_2'}]} \Rightarrow_B \top}
                  {\Braket{p_1(p_2),e} \Rightarrow_B \top}
\\									
&									{,e(p_1) = \Braket{S_1,p_1'}, e(p_2) = \Braket{S_2,p_2'}}
\\\\
&\inference[$\text{INVOKE}_{B\bot}$]{\Braket{S_1,e[p_1' \mapsto \Braket{S_2,p_2'}]} \Rightarrow_B \bot}
                  {\Braket{p_1(p_2),e} \Rightarrow_B \bot}
\\									
&									{,e(p_1) = \Braket{S_1,p_1'}, e(p_2) = \Braket{S_2,p_2'}}
\\\\
&\inference[$\text{PARENS}_\text{B}$]{e \vdash b_1 \Rightarrow_B b_1'}
                       {e \vdash (b_1) \Rightarrow_B (b_1')}
\\\\
&\inference[$\text{NOT}_\top$]{e \vdash b_1 \Rightarrow_B \top}
                       {e \vdash \Tnot b_1 \Rightarrow_B \bot}
\\\\
&\inference[$\text{NOT}_\bot$]{e \vdash b_1 \Rightarrow_B \bot}
                       {e \vdash \Tnot b_1 \Rightarrow_B \top}
\\\\
&\inference[$\text{AND}_1$]{e \vdash b_1 \Rightarrow_B \bot}
                    {e \vdash b_1 \Tand b_2 \Rightarrow_B \bot}
\\\\
&\inference[$\text{AND}_2$]{e \vdash b_1 \Rightarrow_B \top \\ b_2 \Rightarrow_B \bot}
								    {e \vdash b_1 \Tand b_2 \Rightarrow_B \bot}
\\\\
&\inference[$\text{AND}_3$]{e \vdash b_1 \Rightarrow_B \top \\ b_2 \Rightarrow_B \top}
								    {e \vdash b_1 \Tand b_2 \Rightarrow_B \top}
\\\\
&\inference[NAND]{}
								   {e \vdash b_1 \Tnand b_2 \Rightarrow_B \Tnot( b_1 \Tand b_2 )}
\\\\
&\inference[OR]{}
                 {e \vdash b_1 \Tor b_2 \Rightarrow_B \Tnot(\Tnot b_1 \Tand \Tnot b_2)}
\\\\
&\inference[NOR]{}
								   {e \vdash b_1 \Tnor b_2 \Rightarrow_B \Tnot( b_1 \Tor b_2 )}
\\\\
&\inference[XOR]{}
                  {e \vdash b_1 \Txor b_2 \Rightarrow_B (\Tnot(b_1 \Tand b_2)) \Tand (b_1 \Tor b_2)}
\end{align*}

\subsection{Logical Expressions}
\begin{align*}
&\inference[$\text{EQUALS}_\text{L}$]{e \vdash a_1 \Rightarrow_B a_1'}
                    {e \vdash a_1 = a_2 \Rightarrow_B a_1' = a_2}
&
&\inference[$\text{EQUALS}_\text{R}$]{e \vdash a_1 \Rightarrow_B a_1'}
                    {e \vdash a_2 = a_1 \Rightarrow_B a_2 = a_1'}
\\\\
&\inference[$\text{EQUALS}_\text{V1}$]{}
                    {v_1 = v_2 \Rightarrow_B \top}
										{, v_1 = v_2}
&
&\inference[$\text{EQUALS}_\text{V2}$]{}
                    {v_1 = v_2 \Rightarrow_B \bot}
										{, v_1 \neq v_2}
\\\\
&\inference[$NEQUALS$]{}
                    {e \vdash a_1 != a_2 \Rightarrow_B \Tnot (a_1 = a_2)}
\\\\
&\inference[$\text{GT}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 > a_2 \Rightarrow_A a_1' > a_2}
&
&\inference[$\text{GT}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 > a_1 \Rightarrow_A a_2 > a_1'}
\\\\
&\inference[$\text{GT}_\text{V1}$]{}
                    {v_1 > v_2 \Rightarrow_B \top}
										{, v_1 > v_2}
&
&\inference[$\text{GT}_\text{V2}$]{}
                    {v_1 > v_2 \Rightarrow_B \bot}
										{, v_1 \leq v_2}
\\\\
&\inference[$GTEQ$]{}
                    {e \vdash a_1 >= a_2 \Rightarrow_A (a_1 > a_2) \Tor (a_1 = a_2)}
\\\\
&\inference[$\text{LT}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 < a_2 \Rightarrow_A a_1' < a_2}
&
&\inference[$\text{LT}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 < a_1 \Rightarrow_A a_2 < a_1'}
\\\\
&\inference[$\text{LT}_\text{V1}$]{}
                    {v_1 < v_2 \Rightarrow_B \top}
										{, v_1 < v_2}
&
&\inference[$\text{LT}_\text{V2}$]{}
                    {v_1 < v_2 \Rightarrow_B \bot}
										{, v_1 \geq v_2}
\\\\
&\inference[$LTEQ$]{}
                    {e \vdash a_1 <= a_2 \Rightarrow_A (a_1 < a_2) \Tor (a_1 = a_2)}
\end{align*}
\subsection{Statements}
\newcommand{\Tx}{\mathbin{\; \text{x} \;}}
\newcommand{\Tlet}{\text{let}}
\newcommand{\Tvar}{\text{var}}
\subsubsection{General}
\begin{align*}
%&\inference[$\text{DECL}$]{}
%                         {\Braket{\Tlet x := a,e,st} \Rightarrow_S \Braket{x := a, e',st}}
%												{, l = e(next), e' = e[x\mapsto l, next\mapsto new(l)]}
%\\\\
&\inference[$\text{INIT}_{SYM}$]{}
                         {\Braket{\Tlet \Tx := S,e} \Rightarrow_S e'}
												 {, e' = e[\Tx \mapsto \Braket{S,\epsilon}]}
\\\\
&\inference[$\text{INIT}_{FUNC}$]{}
                         {\Braket{\Tlet \Tx(y) := S,e} \Rightarrow_S e'}
												 {, e' = e[\Tx \mapsto \Braket{S,y}]}
\\\\
&\inference[$\text{INIT}$]{}
                         {\Braket{\Tvar \Tx := S,e} \Rightarrow_S e'}
												 {, e' = e[\Tx \mapsto \Braket{S,\epsilon}]}
\\\\
&\inference[ASS]{}
                 {\Braket{\Tx := S,e} \Rightarrow_S e'}
								 {, e' = e[\Tx \mapsto \Braket{S,\epsilon}]}
\\\\
&\inference[$\text{STATEMENTS}_1$]{\Braket{S_1,e} \Rightarrow_S \Braket{S_1',e'}}
                         {\Braket{S_1;S_2,e} \Rightarrow_S \Braket{S_1';S_2,e'}}
\\\\
&\inference[$\text{STATEMENTS}_2$]{\Braket{S_1,e} \Rightarrow_S e'}
                         {\Braket{S_1;S_2,e} \Rightarrow_S \Braket{S_2,e'}}
\\\\
&\inference[$\text{BLOCK}_1$]{\Braket{S,e} \Rightarrow_S \Braket{S',e'}}
                         {\Braket{\{S\},e} \Rightarrow_S \Braket{\{S'\},e'}}
\\\\
&\inference[$\text{BLOCK}_1$]{\Braket{S,e} \Rightarrow_S e'}
                         {\Braket{\{S\},e} \Rightarrow_S e'}
\end{align*}

\subsubsection{Conditional}
\newcommand{\Tif}{\text{if}}
\newcommand{\Telse}{\text{else}}

\begin{align*}
&\inference[$\text{IF}_\top$]{}
                      {\Braket{if(b)\{S\},e} \Rightarrow_S \Braket{\{S\},e}}
											{,b \Rightarrow_B \top}
\\\\
&\inference[$\text{IF}_\bot$]{}
                      {\Braket{if(b)\{S\},e} \Rightarrow_S e}
											{,b \Rightarrow_B \bot}
\\\\
&\inference[$\text{IF-ELSE}_\top$]{}
                      {\Braket{if(b)\{S_1\}else\{S_2\},e} \Rightarrow_S \Braket{\{S_1\},e}}
											{,b \Rightarrow_B \top}
\\\\
&\inference[$\text{IF-ELSE}_\bot$]{}
                      {\Braket{if(b)\{S_1\}else\{S_2\},e} \Rightarrow_S \Braket{\{S_2\},e}}
											{,b \Rightarrow_B \bot}
\end{align*}
\subsubsection{Loop}
\newcommand{\Tfor}{\mathbin{\text{for}}}
\newcommand{\Tin}{\mathbin{\text{in}}}
\newcommand{\Twhile}{\mathbin{\text{while}}}

\begin{align*}
&\inference[$\text{WHILE}_\top$]{e \vdash b \Rightarrow_B \top}
                       {\Braket{\Twhile(b)\{S\},e} \Rightarrow_S \Braket{\{S\}; \Twhile (b)\{S\},e}}
\\\\
&\inference[$\text{WHILE}_\bot$]{e \vdash b \Rightarrow_B \bot}
                       {\Braket{\Twhile(b)\{S\},e} \Rightarrow_S e}
\\\\
&\inference[$\text{FOR}_{1}$]{}
                       {\Braket{\Tfor \Tx \Tin [n_1,\dots,n_m]\{S\},e} \Rightarrow_S \Braket{x := n_1;\{S\}; \Tfor \mathbin{\text{x}} \mathbin{\text{in}} [n_2,\dots,n_m]\{S\},e}}
\\\\
&\inference[$\text{FOR}_{2}$]{}
                       {\Braket{\Tfor \mathbin{\text{x}} \mathbin{\text{in}} [n_m]\{S\},e} \Rightarrow_S \Braket{x := n_m;\{S\},e}}
\end{align*}

\subsubsection{Misc}
\newcommand{\Tspawn}{\mathbin{\text{spawn}}}
\newcommand{\Tsend}{\mathbin{\text{send}}}
\newcommand{\Ta}{\; \mathbin{\text{a}} \;}
\newcommand{\Tm}{\; \mathbin{\text{m}} \;}
\newcommand{\Twhere}{\mathbin{\text{where}}}
\newcommand{\Ten}{\mathbin{\text{env}}}
\newcommand{\Tactor}{\mathbin{\text{actor}} \;}
\newcommand{\Tact}{\; \mathbin{\text{act}} \;}
\newcommand{\Trecieve}{\mathbin{\text{recieve}} \;}
\newcommand{\Tr}{\; \mathbin{\text{r}} \;}

\begin{align*}
&\inference[TYPEOF]{}
                  {e \vdash m \Rightarrow_T t}
									{, \mathbb{T}(n) = t}
\\\\
&\inference[$\text{ACTOR}$]{a' = a[\Tact \mapsto e]}
                           {\Braket{\Tactor \Tact := \{S\};,a} \Rightarrow_S \Braket{S,e,a'}}
\\\\
&\inference[$\text{RECIEVE}$]{}
                           {\Braket{\Trecieve r:t := \{S\};,e} \Rightarrow_S \Braket{e[\_t \mapsto \Braket{S,r}]}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The left side of a parallel statement is executed, but not finished. The environment and actor model is updated when executing $S_1$.}
&\inference[$\text{PAR}_1$]{\Braket{S_1,e_1,\alpha} \Rightarrow_S \Braket{S_1',e_1',\alpha'}} 
                           {\Braket{S_1,e_1,\alpha}|\Braket{S_2,e_2,\alpha} \Rightarrow_S \Braket{S_1',e_1',\alpha'}|\Braket{S_2,e_2,\alpha'}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The left side of a parallel statement is executed, and finishes. The environment and actor model is updated when executing $S_1$.}
&\inference[$\text{PAR}_2$]{\Braket{S_1,e_1,\alpha} \Rightarrow_S \Braket{e_1',\alpha'}} 
                           {\Braket{S_1,e_1,\alpha}|\Braket{S_2,e_2,\alpha} \Rightarrow_S \Braket{S_2,e_2,\alpha'}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The right side of a parallel statement is executed, but not finished. The environment and actor model is updated when executing $S_2$.}
&\inference[$\text{PAR}_3$]{\Braket{S_2,e_1,\alpha} \Rightarrow_S \Braket{S_2',e_1',\alpha'}} 
                           {\Braket{S_1,e_1,\alpha}|\Braket{S_2,e_2,\alpha} \Rightarrow_S \Braket{S_1',e_1',\alpha'}|\Braket{S_2,e_2,\alpha'}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The right side of a parallel statement is executed, and finishes. The environment and actor model is updated when executing $S_2$.}
&\inference[$\text{PAR}_4$]{\Braket{S_2,e_1} \Rightarrow_S \Braket{e_1',\alpha'}}
                           {\Braket{S_1,e_1,\alpha}|\Braket{S_2,e_2,\alpha} \Rightarrow_S \Braket{S_1',e_1',\alpha'}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{SPAWN}$]{}
                       {\Braket{\Ta := \Tspawn \Tx \Tm,\alpha} \Rightarrow_S \Braket{\Tsend \Ta \Tm,\alpha'}}
\\
&												{, \alpha(x) \mapsto \Braket{S,p} , \alpha' = \alpha[\Ta \mapsto \Braket{S, p}]}
\\\\
&\inference[$\text{SEND}$]{e_2 = a(act),m \Rightarrow_T t}
                       {\Braket{\Tsend \Tact \Tm ; S,\alpha,e_1} \Rightarrow_S \Braket{S,e_1,a}|\Braket{\_t(m),e_2,a}}
\\\\
&\inference[$\text{MAIN}$]{input \mapsto \Braket{S,\epsilon}}
                          {\Braket{\Trecieve \Tr:args := \{S\};,e} \Rightarrow_S \Braket{\Tr := input;S, e]}}
\end{align*}