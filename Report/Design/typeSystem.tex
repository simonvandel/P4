\section{Type System}

The goal of the type system is to minimise programming errors, but on the other hand not being too restrictive so the expressiveness of the language is reduced. 

The Language Described in this Report is a statically typed language. Statically typed languages have the following nice properties, that do not apply to dynamically typed languages.

\begin{itemize}
  \item Type errors are presented at the soonest possible level: compile-time. This makes it impossible to have a program stop unexpectedly because of a type error at run-time
  \item Because of the fact that types are checked at compile time, no overhead is imposed to the compiled program at run-time
\end{itemize}

Of course, dynamically typed languages have its uses. One can argue that prototyping a program is done faster in a dynamically typed language. The trade-off is usually expressiveness for safety and performance.

In order to reduce the mental overhead and the number of explicit type declarations to write in a language, type inference can be implemented in the compiler. Having almost all types inferred by the compiler makes the language have more of the same feel as a dynamically typed language, in that there is less mental overhead for the user. Using a statically typed language with type inference brings all the beneficial properties of statically typed language, combined with a \enquote{lighter} feel.

\subsection{Strictness}

The type system defined in this report can be described as a \emph{strong} type system, as opposed to a \emph{weak} type system. No formal definitions of such categorisations of type systems exist, so this report will use the following understanding of \emph{weak} and \emph{strong} type systems. A type system goes from \emph{weak} to \emph{strong} as the number of undefined behaviour, unpredictable behaviour or implicit conversions between types approach zero.

Using the above definition the type system can be categorised as \emph{strong}, as only one implicit conversion is made between values of type \emph{int} to values of type \emph{real}, whenever number precision can be preserved. Other than that, the type system should be predictable.

\input{Design/metaType.tex}

\subsection{Type Rules}

\subsubsection{Common Notation}
\textbf{Operators}
\begin{align*}
&\textrm{let} \;\; AOP = [+, -, *, /, \%, \;^\wedge{} \;]
&
&\textrm{let} \;\; BAOP = [=, !=, <, <=, >, >=]
\\\\
&\textrm{let} \;\; BBOP = [\textrm{AND, NAND, OR, NOR, XOR}]
\end{align*}
\textbf{Types}
\begin{align*}
&\textrm{let} \;\; BT = [int, real, bool, char]
&
&\textrm{let} \;\; BL = [[BL], BT, TUPLE, struct<TUPLE>]
\\\\
&\textrm{let} \;\; TUPLE = (BT, BT^+)
\end{align*}
\subsubsection{Arithmetic Expressions}
\begin{align*}
&\inference[$EXPR_{int,int}$]{E \vdash e_1 : int \\
                       E \vdash e_2 : int}
                    {E \vdash e_1 \mathbin{\textrm{AOP}} e_2 : int}
&
&\inference[$EXPR_{int,real}$]{E \vdash e_1 : int \\
                       E \vdash e_2 : real}
                    {E \vdash e_1 \mathbin{\textrm{AOP}} e_2 : real}
\\\\
&\inference[$EXPR_{real,int}$]{E \vdash e_1 : real \\
                       E \vdash e_2 : int}
                    {E \vdash e_1 \mathbin{\textrm{AOP}} e_2 : real}
&
&\inference[$EXPR_{real,real}$]{E \vdash e_1 : real \\
                       E \vdash e_2 : real}
                    {E \vdash e_1 \mathbin{\textrm{AOP}} e_2 : real}
\\\\  
&\inference[$ROOT_{int,int}$]{E \vdash e_1 : int \\
                       E \vdash e_2 : int}
                    {E \vdash e_1 \mathbin{\#} e_2 : real}
&
&\inference[$ROOT_{int,real}$]{E \vdash e_1 : int \\
                       E \vdash e_2 : real}
                    {E \vdash e_1 \mathbin{\#} e_2 : real}
\\\\
&\inference[$ROOT_{real,int}$]{E \vdash e_1 : real \\
                       E \vdash e_2 : int}
                    {E \vdash e_1 \mathbin{\#} e_2 : real}
&
&\inference[$ROOT_{real,real}$]{E \vdash e_1 : real \\
                       E \vdash e_2 : real}
                    {E \vdash e_1 \mathbin{\#} e_2 : real}
\end{align*}

\subsubsection{Boolean Expressions}
\begin{align*}
&\inference[$BOOL_{BAOP-int,int}$]{E \vdash e_1 : int \\
                       E \vdash e_2 : int}
                    {E \vdash e_1 \mathbin{\textrm{BAOP}} e_2 : bool}
&
&\inference[$BOOL_{BAOP-int,float}$]{E \vdash e_1 : int \\
                       E \vdash e_2 : float}
                    {E \vdash e_1 \mathbin{\textrm{BAOP}} e_2 : bool}
\\\\
&\inference[$BOOL_{BAOP-float,int}$]{E \vdash e_1 : float \\
                       E \vdash e_2 : int}
                    {E \vdash e_1 \mathbin{\textrm{BAOP}} e_2 : bool}
&
&\inference[$BOOL_{BAOP-float,float}$]{E \vdash e_1 : float \\
                       E \vdash e_2 : float}
                    {E \vdash e_1 \mathbin{\textrm{BAOP}} e_2 : bool}
\\\\
&\inference[$BOOL_{EQUALS}$]{E \vdash e_1 : BL \\
                       E \vdash e_2 : BL}
                    {E \vdash e_1 = e_2 : bool}
&
&\inference[$BOOL_{NEQUALS}$]{E \vdash e_1 : BL \\
                       E \vdash e_2 : BL}
                    {E \vdash e_1 != e_2 : bool}
\\\\
&\inference[$BOOL_{BBOP}$]{E \vdash e_1 : bool \\
                       E \vdash e_2 : bool}
                    {E \vdash e_1 \mathbin{\textrm{BBOP}} e_2 : bool}
\end{align*}
\subsubsection{Conditional Expressions}
\begin{align*}
&\inference[$IF$]{E \vdash b : bool \\
                  E \vdash e : BL}
                 {E \vdash \mathbin{\textrm{if}} \; (b) \; {e}: void}
&
&\inference[$IF-ELSE$]{E \vdash b : bool \\
                  E \vdash e_1 : BL \\
                  E \vdash e_2 : BL'}
                 {E \vdash \mathbin{\textrm{if}} \; (b) \; {e_1} \mathbin{\textrm{else}} {e_2}: void}
\end{align*}

\subsubsection{Loop Expressions}
\begin{align*}
&\inference[$WHILE$]{E \vdash b : bool \\
                  E \vdash e : BT}
                 {E \vdash \mathbin{\textrm{while}} \; (b) \; {e}: void}
&
&\inference[$FOR$]{E \vdash l : [BT] \\
                  E \vdash e : BT'}
                 {E \vdash \mathbin{\textrm{for}} \; \mathbin{\textrm{x}} \; \mathbin{\textrm{in}} \; {l} \; \{e\}: void	| E \vdash x : BT}
\\\\
&\inference[$FOR$]{E \vdash l : [BT] \\
                  E \vdash e : BT' \\
									E \vdash y : int}
                 {E \vdash \mathbin{\textrm{for}} (x,y) \mathbin{\textrm{in}} \; {l} \; \{e\}: void	| E \vdash x : BT}
\end{align*}