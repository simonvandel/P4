\section{Type System}

The type system for The Language Described in this Report is \emph{strong} statically typed. No implicit type conversions are made in the type system. This section describes some design choices about the type system.

\subsection{Higher Kinded Types}
An example of a program snippet declaring symbol \emph{x} with the kind \emph{*} and assigning it to \emph{int} can be seen below.

\begin{verbatim}
  let x:* := int
\end{verbatim}

This assignment is perfectly legal syntactically and semantically. Consider however the example below, in which a variable symbol initialisation takes place.

\begin{verbatim}
  var y:* := int
  var z:y := 4
  y := bool
  z := 5
\end{verbatim}

In this example, the mutable binding to y is initially bound to \emph{int}. The binding \emph{z} has the type of \emph{y} i.e. \emph{int}. On line 3, the type of \emph{y} is reassigned to \emph{bool}. On line 4, problems occur when \emph{z} is trying to be reassigned to \emph{5} which is of type \emph{int} and therefor not the correct type of \emph{bool}.

On solution to avoiding this problem, is to disallow mutable symbol bindings which is a kind. This would allow \emph{let y:* := int}, but disallow \emph{var y:* := int}. Another solution is to not include higher kinded types in the type system.

To avoid the confusion of the users of the language not knowing when it is allowed to have mutable bindings, the type system for The Language Described in this Report does not support higher kinded types.

\subsection{Type Rules}

% macros for symbols:
\newcommand{\Tpot}{^\wedge{}}
\newcommand{\Tint}{\text{int}}
\newcommand{\Treal}{\text{real}}
\newcommand{\Tbool}{\text{bool}}
\newcommand{\Tchar}{\text{char}}
\newcommand{\Tvoid}{\text{void}}
\newcommand{\Taop}{\text{AOP}}
\newcommand{\Tbaop}{\text{BAOP}}
\newcommand{\Tbbop}{\text{BBOP}}
\newcommand{\Tbl}{\text{BL}}
\newcommand{\Tbt}{\text{BT}}
\newcommand{\Tenv}{E \vdash}

\subsubsection{Common Notation}
The following variables are used when any elements of the set can be used. For example the variable $AOP$ can be a $+$.
\paragraph{Operators}
\begin{align*}
&\Taop = \left\{ {+, -, *, /, \%, \; \Tpot \;} \right\}
\\
&\Tbaop = \left\{ {<, <=, >, >=} \right\}
\\
&\Tbbop = \left\{ {\text{AND, NAND, OR, NOR, XOR}} \right\}
\end{align*}

\paragraph{Types}
\begin{align*}
&\Tbt = \left\{ {\Tint, \Treal, \Tbool, \Tchar} \right\}
\\
&\text{TUPLE} = (\Tbl, \Tbl^+)
\\            
&\Tbl = \left\{ { \left[ \Tbl \right], \Tbt, \text{TUPLE}, \text{struct<TUPLE>}} \right\}
\end{align*}

\subsubsection{Arithmetic Expressions}
\begin{align*}
&\inference[$\text{EXPR}_{\Tint,\Tint}$]{\Tenv e_1  : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\Taop} e_2 : \Tint}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{EXPR}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal & 
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\Taop} e_2 : \Treal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Tint,\Tint}$]{\Tenv e_1 : \Tint &
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
\end{align*}
\sinote{root med ints -> int er endnu ikke komplet. Skal det altid give en real?}

\subsubsection{Boolean Expressions}
\begin{align*}
&\inference[$\text{BOOL}_{\Tbaop-\Tint,\Tint}$]{\Tenv e_1 : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\Tbaop} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{\Tbaop-\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\Tbaop} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{EQUALS}$]{\Tenv e_1 : \Tbl &
                       \Tenv e_2 : \Tbl}
                    {\Tenv e_1 = e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{NEQUALS}$]{\Tenv e_1 : \Tbl &
                       \Tenv e_2 : \Tbl}
                    {\Tenv e_1 \mathbin{\text{!=}} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{BBOP}$]{\Tenv e_1 : \Tbool &
                       \Tenv e_2 : \Tbool}
                    {\Tenv e_1 \mathbin{\Tbbop} e_2 : \Tbool}
\end{align*}
\subsubsection{Conditional Expressions}
\begin{align*}
\intertext{The conditional body of a if-statement must be of type bool. The body can be of any type defined in $\Tbl$. The type of the if-statement is void.}
&\inference[$\text{IF}$]{\Tenv b : \Tbool &
                  \Tenv e : \Tbl}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e\}: \Tvoid}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The conditional body of a if-else-statement must be of type bool. The two bodies can be of any type defined in $\Tbl$. The type of the if-else-statement is void.}
&\inference[$\text{IF-ELSE}$]{\Tenv b : \Tbool &
                  \Tenv e_1 : \Tbl &
                  \Tenv e_2 : \Tbl'}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e_1\} \mathbin{\text{else}} \{e_2\}: \Tvoid}
\end{align*}

\subsubsection{Loop Expressions}
\begin{align*}
\intertext{The conditional body of the while construct must be of type bool. The body of the while-loop can be of any type defined in $\Tbl$}
&\inference[WHILE]{\Tenv b : \Tbool &
                  \Tenv e : \Tbt}
                 {\Tenv \mathbin{\text{while}} \; (b) \; {e}: \Tvoid}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{For loops can only work on lists. The counter variable is the type of a element in the list being iterated.}
&\inference[FOR]{\Tenv l : [\Tbt]}
                 {\Tenv \mathbin{\text{for}} \; \mathbin{\text{x}} \; \mathbin{\text{in}} \; {l} \; : \Tvoid },	 \Tenv x : \Tbt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\                                  
&\inference[FOR]{\Tenv l : [\Tbt]} 
                 {\Tenv \mathbin{\text{for}} (x,y) \mathbin{\text{in}} \; {l} \; : \Tvoid } , \Tenv x : \Tbt, \Tenv y : \Tint
\end{align*}

\subsubsection{Match statements}
\begin{align*}
\intertext{When matching on an expression of type $\Tbl$ each match case must be of the same type as the expression. There can be multiple match cases as denoted by the plus. The body of each match case can be any type of $\Tbl'$ different from the type of the expression being matched on. The whole match statement has type void.}
&\inference[MATCH]{\Tenv e_1 : \Tbl &
                   \Tenv e_2 : \Tbl &
                   \Tenv S : \Tbl'}
                 {\Tenv \mathbin{\text{match}} \; e_1 \; {(e_2 -> S)^+}: \Tvoid}
\end{align*}