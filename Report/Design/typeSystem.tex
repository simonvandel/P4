\section{Type System}\label{typesys}

This section first defines what a type system is and presents two categories of type systems. The two type system categories are described and its properties are outlined.

Later in this section, the type system decisions made for TLDR are described, and formal type rules are given.

\subsection{General Type Systems}

The goal of the type system is to minimise programming errors, while on the other hand not being too restrictive, such that the expressiveness of the language is not reduced. 

\subsubsection{Strictness}
Type systems are often described as \emph{strong} or \emph{weak}. No formal definitions of such categorisations of type systems exist, so this report will use the following understanding of \emph{weak} and \emph{strong} type systems. A type system goes from \emph{weak} to \emph{strong} as the amount of undefined behaviour, unpredictable behaviour or implicit conversions between types approach zero.

\subsubsection{Static Versus Dynamic Type Systems}
Languages can generally be categorised into dynamically typed and statically typed languages. The difference between static and dynamic typing is the time of type checking. In static typing, types are checked at compile time. In dynamic typing, types are checked at run-time.

Statically typed languages have the following advantages over dynamically typed languages.

\begin{itemize}
  \item Type errors are presented at the soonest possible level; compile-time. This makes it impossible to have a program stop unexpectedly because of a type error at run-time
  \item Because of the fact that types are checked at compile time, no overhead is imposed on the compiled program at run-time
\end{itemize}

Of course dynamically typed languages have their uses. One can argue that prototyping a program is done faster in a dynamically typed language because the programmer does not need to think of types when programming. The mental overhead is usually lower. The trade-off of dynamic typing versus static typing is often expressiveness for safety and performance.

\subsubsection{Type Inference}
Type checking solves the problem of determining if a program is well-typed i.e. does not have any type errors. Type inference can be seen as solving the opposite problem; determine types in a program, making the program well-typed.

In order to reduce the mental overhead and the number of explicit type declarations to write in a language, type inference can be implemented in the compiler. Having types inferred by the compiler in a statically typed language makes the language as expressive as a dynamically typed language, whilst keeping the safety and performance of static typing.

\subsubsection{Summary}
Type systems are defined by the type rules it enforces. Because the strictness of the type rules can vary, type systems can range from being very strict to being very weak.

Generally two different approaches exist to solve the goal of minimising errors in programs. Static typing checks types at compile-time and therefore is able to present type errors at a early stage. Because of this, static typing is often regarded as safer and more performant.

Dynamic typing checks types at run-time and therefore allows the programmer to not have the same mental overhead of thinking about types when programming. This however comes at the price of safety and performance.

Type inference removes the need to explicitly annotate programs with type annotations. This can reduce the mental overhead associated with static typing.

\subsection{Type System Choice for TLDR}

This section describes some design choices about the type system used for TLDR.

\subsubsection{Strictness \& Statical Typing}
The type system for TLDR is \emph{strong} statically typed. No implicit type conversions are made in the type system. This choice of static typing was made based on the domain in which TLDR is meant to be used. Having type errors presented early on in the process of developing programs in the language, means much stronger guarantees can be made about the final running program. This is important because running programs on large systems or distributed systems is costly; whenever a program is run on such systems, the program should produce the expected result without run-time failures. 

\subsubsection{Type Rules}

% macros for symbols:
\newcommand{\Tpot}{^\wedge{}}
\newcommand{\Tint}{\text{int}}
\newcommand{\Treal}{\text{real}}
\newcommand{\Tbool}{\text{bool}}
\newcommand{\Tchar}{\text{char}}
\newcommand{\Taop}{\text{AOP}}
\newcommand{\Tbaop}{\text{BAOP}}
\newcommand{\Tbop}{\text{BOP}}
\newcommand{\Tt}{\text{T}}
\newcommand{\Tpt}{\text{PT}}
\newcommand{\Tenv}{E \vdash}

\begin{align*}
\intertext{The following sets will be used throughout this section}
&\Taop = \left\{ {+, -, *, /, \%, \; \Tpot \;} \right\}
\\
&\Tbaop = \left\{ {<, <=, >, >=} \right\}
\\
&\Tbop = \left\{ {\text{AND, NAND, OR, NOR, XOR}} \right\}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The following primitive types are defined}
&\Tpt ::= \Tint \mid \Treal \mid \Tbool \mid \Tchar
\\
\intertext{A tuple is a finite set of ordered elements of arbitrary type $T$}
&\text{TUPLE} ::= T_1 \times T_2 \times \ldots \times T_n
\\            
&\text{B} ::=  \left[ \Tt \right] \mid \Tpt \mid \text{TUPLE} \mid \text{struct<TUPLE>}
\\            
\intertext{All types defined in the type system is defined in $T$.}
&\Tt ::= \text{B} \mid x : B \rightarrow ok
\end{align*}

\paragraph{Arithmetic Expressions}
\begin{align*}
&\inference[$\text{EXPR}_{\Tint,\Tint}$]{\Tenv e_1  : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tint},  \text{op} \in \Taop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{EXPR}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal & 
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Treal},  \text{op} \in \Taop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Tint,\Tint}$]{\Tenv e_1 : \Tint &
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
\end{align*}
\sinote{root med ints -> int er endnu ikke komplet. Skal det altid give en real?}

\paragraph{Boolean Expressions}
\begin{align*}
&\inference[$\text{BOOL}_{\Tbaop-\Tint,\Tint}$]{\Tenv e_1 : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tbool}, \text{op} \in \Tbaop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{\Tbaop-\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tbool}, \text{op} \in \Tbaop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{EQUALS}$]{\Tenv e_1 : \Tt &
                       \Tenv e_2 : \Tt}
                    {\Tenv e_1 = e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{NEQUALS}$]{\Tenv e_1 : \Tt &
                       \Tenv e_2 : \Tt}
                    {\Tenv e_1 \mathbin{\text{!=}} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{BBOP}$]{\Tenv e_1 : \Tbool &
                       \Tenv e_2 : \Tbool}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tbool}, \text{op} \in \Tbop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{NOT}$]{\Tenv e : \Tbool}
                    {\Tenv \mathbin{\text{NOT}} \; e : \Tbool}
\end{align*}
\paragraph{Conditional Expressions}
\begin{align*}
\intertext{The conditional body of a if-statement must be of type bool. The body can be of any type defined in $\Tt$. The type of the if-statement is well-typed.}
&\inference[$\text{IF}$]{\Tenv b : \Tbool &
                  \Tenv e : \Tt}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e\}: ok}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The conditional body of a if-else-statement must be of type bool. The two bodies can be of any type defined in $\Tt$. The type of the if-else-statement is well-typed.}
&\inference[$\text{IF-ELSE}$]{\Tenv b : \Tbool &
                  \Tenv e_1 : \Tt &
                  \Tenv e_2 : \Tt}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e_1\} \mathbin{\text{else}} \{e_2\}: ok}
\end{align*}

\paragraph{Loop Expressions}
\begin{align*}
\intertext{The conditional body of the while construct must be of type bool. The body of the while-loop can be of any type defined in $\Tt$}
&\inference[WHILE]{\Tenv b : \Tbool &
                  \Tenv e : \Tt}
                 {\Tenv \mathbin{\text{while}} \; (b) \; {e}: ok}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{For loops can only work on lists. The counter variable is the type of a element in the list being iterated.}
&\inference[FOR]{\Tenv l : [\Tpt]}
                 {\Tenv \mathbin{\text{for}} \; \mathbin{\text{x}} \; \mathbin{\text{in}} \; {l} \; : ok },	 \Tenv x : \Tpt
\end{align*}


\paragraph{Actor Expressions}
\begin{align*}
\intertext{}
&\inference[SPAWN]{}
                 {\Tenv \mathbin{\text{spawn}} \; \Tt: \Tt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[SEND]{\Tenv m : \Tt & \Tenv a: \Tt'}
                 {\Tenv \mathbin{\text{send}} \; \mathbin{\text{m}} \; \mathbin{\text{a}} : ok }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[RECEIVE]{\Tenv m : \Tt}
                 {\Tenv \mathbin{\text{recieve}} \; \mathbin{\text{m}} :\Tt : ok }
\end{align*}

\paragraph{Comparison}
\begin{align*}
\intertext{}
&\inference[ACTOR]{\Tenv e_1: \Tt & \Tenv e_2: \Tt}
                 {\Tenv e_1 = e_2: \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[STRUCT]{\Tenv e_1: \Tt & \Tenv e_2: \Tt}
                 {\Tenv e_1 = e_2: \Tbool}
\end{align*}

\paragraph{Misc constructs}
\begin{align*}
\intertext{}
&\inference[BLOCK]{\Tenv s_1: \Tt & \Tenv s_2: \Tt'}
                 {\Tenv \{s_1; s_2\} : \Tt'}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[LET]{}
                 {\Tenv \mathbin{\text{let}} \; e:T: ok}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[VAR]{}
                 {\Tenv \mathbin{\text{var}} \; e:T: ok}
                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[LET1]{\Tenv e_1: \Tt & \Tenv e_2: \Tt}
                 {\Tenv \mathbin{\text{let}} \; e_1 := e_2: ok}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[VAR1]{\Tenv e_1: \Tt & \Tenv e_2: \Tt}
                 {\Tenv \mathbin{\text{var}} \; e_1 := e_2: ok}
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[NUM]{\Tenv n:\Tint}
                 {\Tenv n: \Tint} 
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[NUM1]{\Tenv n_1:\Tint & \Tenv n_2:\Tint}
                 {\Tenv n_1.n_2: \Treal}    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{}
&\inference[INVOKE]{\Tenv n: \Tt}
                 {\Tenv n: \Tt}
\end{align*}


