\section{Type System}
This section describes some design choices about the type system used for The Language Described in this Report.

\subsection{Strictness \& Statical Typing}
The type system for The Language Described in this Report is \emph{strong} statically typed. No implicit type conversions are made in the type system. This choice of static typing was made based on the domain in which The Language Described in this Report is meant to be used. Having type errors presented early on in the process of developing programs in the language, means much stronger guarantees can be made about the final running program. This is important because running programs on large systems or distributed systems is costly; whenever a program is run on such systems, the program should produce the expected result without run-time failures. 

\subsection{Type Rules}

% macros for symbols:
\newcommand{\Tpot}{^\wedge{}}
\newcommand{\Tint}{\text{int}}
\newcommand{\Treal}{\text{real}}
\newcommand{\Tbool}{\text{bool}}
\newcommand{\Tchar}{\text{char}}
\newcommand{\Taop}{\text{AOP}}
\newcommand{\Tbaop}{\text{BAOP}}
\newcommand{\Tbop}{\text{BOP}}
\newcommand{\Tt}{\text{T}}
\newcommand{\Tpt}{\text{PT}}
\newcommand{\Tenv}{E \vdash}

\begin{align*}
\intertext{The following sets will be used throughout this section}
&\Taop = \left\{ {+, -, *, /, \%, \; \Tpot \;} \right\}
\\
&\Tbaop = \left\{ {<, <=, >, >=} \right\}
\\
&\Tbop = \left\{ {\text{AND, NAND, OR, NOR, XOR}} \right\}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The following primitive types are defined}
&\Tpt ::= \Tint \mid \Treal \mid \Tbool \mid \Tchar
\\
\intertext{A tuple is a finite set of ordered elements of arbitrary type $T$}
&\text{TUPLE} ::= T_1 \times T_2 \times \ldots \times T_n
\\            
&\text{B} ::=  \left[ \Tt \right] \mid \Tpt \mid \text{TUPLE} \mid \text{struct<TUPLE>}
\\            
\intertext{All types defined in the type system is defined in $T$.}
&\Tt ::= \text{B} \mid x : B \rightarrow ok
\end{align*}

\subsubsection{Arithmetic Expressions}
\begin{align*}
&\inference[$\text{EXPR}_{\Tint,\Tint}$]{\Tenv e_1  : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tint},  \text{op} \in \Taop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{EXPR}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal & 
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Treal},  \text{op} \in \Taop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Tint,\Tint}$]{\Tenv e_1 : \Tint &
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
\end{align*}
\sinote{root med ints -> int er endnu ikke komplet. Skal det altid give en real?}

\subsubsection{Boolean Expressions}
\begin{align*}
&\inference[$\text{BOOL}_{\Tbaop-\Tint,\Tint}$]{\Tenv e_1 : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tbool}, \text{op} \in \Tbaop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{\Tbaop-\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tbool}, \text{op} \in \Tbaop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{EQUALS}$]{\Tenv e_1 : \Tt &
                       \Tenv e_2 : \Tt}
                    {\Tenv e_1 = e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{NEQUALS}$]{\Tenv e_1 : \Tt &
                       \Tenv e_2 : \Tt}
                    {\Tenv e_1 \mathbin{\text{!=}} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{BBOP}$]{\Tenv e_1 : \Tbool &
                       \Tenv e_2 : \Tbool}
                    {\Tenv e_1 \mathbin{\text{op}} e_2 : \Tbool}, \text{op} \in \Tbop
\end{align*}
\subsubsection{Conditional Expressions}
\begin{align*}
\intertext{The conditional body of a if-statement must be of type bool. The body can be of any type defined in $\Tt$. The type of the if-statement is well-typed.}
&\inference[$\text{IF}$]{\Tenv b : \Tbool &
                  \Tenv e : \Tt}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e\}: ok}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The conditional body of a if-else-statement must be of type bool. The two bodies can be of any type defined in $\Tt$. The type of the if-else-statement is well-typed.}
&\inference[$\text{IF-ELSE}$]{\Tenv b : \Tbool &
                  \Tenv e_1 : \Tt &
                  \Tenv e_2 : \Tt}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e_1\} \mathbin{\text{else}} \{e_2\}: ok}
\end{align*}

\subsubsection{Loop Expressions}
\begin{align*}
\intertext{The conditional body of the while construct must be of type bool. The body of the while-loop can be of any type defined in $\Tt$}
&\inference[WHILE]{\Tenv b : \Tbool &
                  \Tenv e : \Tt}
                 {\Tenv \mathbin{\text{while}} \; (b) \; {e}: ok}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{For loops can only work on lists. The counter variable is the type of a element in the list being iterated.}
&\inference[FOR]{\Tenv l : [\Tpt]}
                 {\Tenv \mathbin{\text{for}} \; \mathbin{\text{x}} \; \mathbin{\text{in}} \; {l} \; : ok },	 \Tenv x : \Tpt
\end{align*}
