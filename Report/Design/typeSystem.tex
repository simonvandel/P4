\section{Type System}

The goal of the type system is to minimise programming errors, but on the other hand not being too restrictive so the expressiveness of the language is reduced. 

The Language Described in this Report is a statically typed language. Statically typed languages have the following nice properties, that do not apply to dynamically typed languages.

\begin{itemize}
  \item Type errors are presented at the soonest possible level: compile-time. This makes it impossible to have a program stop unexpectedly because of a type error at run-time
  \item Because of the fact that types are checked at compile time, no overhead is imposed to the compiled program at run-time
\end{itemize}

Of course, dynamically typed languages have its uses. One can argue that prototyping a program is done faster in a dynamically typed language. The trade-off is usually expressiveness for safety and performance.

In order to reduce the mental overhead and the number of explicit type declarations to write in a language, type inference can be implemented in the compiler. Having almost all types inferred by the compiler makes the language have more of the same feel as a dynamically typed language, in that there is less mental overhead for the user. Using a statically typed language with type inference brings all the beneficial properties of statically typed language, combined with a \enquote{lighter} feel.

\subsection{Strictness}

The type system defined in this report can be described as a \emph{strong} type system, as opposed to a \emph{weak} type system. No formal definitions of such categorisations of type systems exist, so this report will use the following understanding of \emph{weak} and \emph{strong} type systems. A type system goes from \emph{weak} to \emph{strong} as the number of undefined behaviour, unpredictable behaviour or implicit conversions between types approach zero.

Using the above definition the type system can be categorised as \emph{strong}, as only one implicit conversion is made between values of type \emph{int} to values of type \emph{real}, whenever number precision can be preserved. Other than that, the type system should be predictable.

\input{Design/metaType.tex}

\subsection{Type Rules}

% macros for symbols:
\newcommand{\Tpot}{^\wedge{}}
\newcommand{\Tint}{\text{int}}
\newcommand{\Treal}{\text{real}}
\newcommand{\Tbool}{\text{bool}}
\newcommand{\Tchar}{\text{char}}
\newcommand{\Tvoid}{\text{void}}
\newcommand{\Taop}{\text{AOP}}
\newcommand{\Tbaop}{\text{BAOP}}
\newcommand{\Tbop}{\text{BOP}}
\newcommand{\Tconct}{\text{CONCT}}
\newcommand{\Tpt}{\text{PT}}
\newcommand{\Tenv}{E \vdash}

\subsubsection{Common Notation}
The following variables are used when any elements of the set can be used. For example the variable $AOP$, Arithmetic OPeration, can be a $+$.
\paragraph{Operators}
\begin{align*}
&\Taop = \left\{ {+, -, *, /, \%, \; \Tpot \;} \right\}
\\
&\Tbaop = \left\{ {<, <=, >, >=} \right\}
\\
&\Tbop = \left\{ {\text{AND, NAND, OR, NOR, XOR}} \right\}
\end{align*}

\paragraph{Types}
\begin{align*}
&\Tpt = \left\{ {\Tint, \Treal, \Tbool, \Tchar} \right\}
\\
&\text{TUPLE} = (\Tconct, \Tconct^+)
\\            
&\Tconct = \left\{ { \left[ \Tconct \right], \Tpt, \text{TUPLE}, \text{struct<TUPLE>}} \right\}
\end{align*}

\subsubsection{Arithmetic Expressions}
\begin{align*}
&\inference[$\text{EXPR}_{\Tint,\Tint}$]{\Tenv e_1  : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\Taop} e_2 : \Tint}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{EXPR}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal & 
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\Taop} e_2 : \Treal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Tint,\Tint}$]{\Tenv e_1 : \Tint &
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{ROOT}_{\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\#} e_2 : \Treal}
\end{align*}
\sinote{root med ints -> int er endnu ikke komplet. Skal det altid give en real?}

\subsubsection{Boolean Expressions}
\begin{align*}
&\inference[$\text{BOOL}_{\Tbaop-\Tint,\Tint}$]{\Tenv e_1 : \Tint & 
                       \Tenv e_2 : \Tint}
                    {\Tenv e_1 \mathbin{\Tbaop} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{\Tbaop-\Treal,\Treal}$]{\Tenv e_1 : \Treal &
                       \Tenv e_2 : \Treal}
                    {\Tenv e_1 \mathbin{\Tbaop} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{EQUALS}$]{\Tenv e_1 : \Tconct &
                       \Tenv e_2 : \Tconct}
                    {\Tenv e_1 = e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{NEQUALS}$]{\Tenv e_1 : \Tconct &
                       \Tenv e_2 : \Tconct}
                    {\Tenv e_1 \mathbin{\text{!=}} e_2 : \Tbool}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\
&\inference[$\text{BOOL}_{BBOP}$]{\Tenv e_1 : \Tbool &
                       \Tenv e_2 : \Tbool}
                    {\Tenv e_1 \mathbin{\Tbop} e_2 : \Tbool}
\end{align*}
\subsubsection{Conditional Expressions}
\begin{align*}
\intertext{The conditional body of a if-statement must be of type bool. The body can be of any type defined in $\Tconct$. The type of the if-statement is void.}
&\inference[$\text{IF}$]{\Tenv b : \Tbool &
                  \Tenv e : \Tconct}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e\}: \Tvoid}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{The conditional body of a if-else-statement must be of type bool. The two bodies can be of any type defined in $\Tconct$. The type of the if-else-statement is void.}
&\inference[$\text{IF-ELSE}$]{\Tenv b : \Tbool &
                  \Tenv e_1 : \Tconct &
                  \Tenv e_2 : \Tconct'}
                 {\Tenv \mathbin{\text{if}} \; (b) \; \{e_1\} \mathbin{\text{else}} \{e_2\}: \Tvoid}
\end{align*}

\subsubsection{Loop Expressions}
\begin{align*}
\intertext{The conditional body of the while construct must be of type bool. The body of the while-loop can be of any type defined in $\Tconct$}
&\inference[WHILE]{\Tenv b : \Tbool &
                  \Tenv e : \Tpt}
                 {\Tenv \mathbin{\text{while}} \; (b) \; {e}: \Tvoid}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\intertext{For loops can only work on lists. The counter variable is the type of a element in the list being iterated.}
&\inference[FOR]{\Tenv l : [\Tpt]}
                 {\Tenv \mathbin{\text{for}} \; \mathbin{\text{x}} \; \mathbin{\text{in}} \; {l} \; : \Tvoid },	 \Tenv x : \Tpt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\\\\                                  
&\inference[FOR]{\Tenv l : [\Tpt]} 
                 {\Tenv \mathbin{\text{for}} (x,y) \mathbin{\text{in}} \; {l} \; : \Tvoid } , \Tenv x : \Tpt, \Tenv y : \Tint
\end{align*}

\subsubsection{Match statements}
\begin{align*}
\intertext{When matching on an expression of type $\Tconct$ each match case must be of the same type as the expression. There can be multiple match cases as denoted by the plus. The body of each match case can be any type of $\Tconct'$ different from the type of the expression being matched on. The whole match statement has type void.}
&\inference[MATCH]{\Tenv e_1 : \Tconct &
                   \Tenv e_2 : \Tconct &
                   \Tenv S : \Tconct'}
                 {\Tenv \mathbin{\text{match}} \; e_1 \; {(e_2 -> S)^+}: \Tvoid}
\end{align*}
