\subsection{Higher Kinded Types}
\label{sub:higher_kinded_types}

Some programming languages allow the notion of higher kinded types, i.e. types of types. A kind is a type of a type constructor. One can describe a kind as one level up from a type. Kinds are often notated using \emph{*}. For example the kind of the type \emph{int} is \emph{*}. The kind of the function type \emph{int -> int} is of kind \emph{* -> *}.

Type systems with support for higher kinded types allow for even more guarantees that can be made about the program at compile-time.

An example of a program snippet declaring symbol \emph{x} with the kind \emph{*} and assigning it to \emph{int} can be seen below.

\begin{verbatim}
  let x:* := int
\end{verbatim}

This assignment is perfectly legal syntactically and semantically. Consider however the example below, in which a variable symbol initialisation takes place.

\begin{verbatim}
  var y:* := int
  var z:y := 4
  y := bool
  z := 5
\end{verbatim}

In this example, the mutable binding to y is initially bound to \emph{int}. The binding \emph{z} has the type of \emph{y} i.e. \emph{int}. On line 3, the type of \emph{y} is reassigned to \emph{bool}. On line 4, problems occur when \emph{z} is trying to be reassigned to \emph{5} which is of type \emph{int} and therefor not the correct type of \emph{bool}.

On solution to avoiding this problem, is to disallow mutable symbol bindings which is a kind. This would allow \emph{let y:* := int}, but disallow \emph{var y:* := int}. Another solution is to not include higher kinded types in the type system.

To avoid the confusion of the users of the language not knowing when it is allowed to have mutable bindings, the type system for The Language Described in this Report does not support higher kinded types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% gammelt afsnit

% It has been decided to design the language in a manner that insures that all type checking can be done at compile time. To insures this; all identifiers must have explicit type declaration.
% A meta type is in this report defined as a type which can be an instance of any other type in the language. %Expand on this
% The functionally which spawns a new actor needs to know of which type the actor should be of, in this case a meta type would be useful to describe the actual type of the actor.
% So to imagine a meta type in this language, it would look something like this: %Bad language and not very academic

% \begin{verbatim}
%   let x:Type := Int
% \end{verbatim}

% In fact $typeX$ is just a placeholder for a type, the following expression should evaluate to int and the declaration of $y$ would be fine. %Fine? Correct?
% But notice that type is declared using the var keyword which makes an variable mutable. %Rephrase
% If $typeX$ is mutable it can change state doing run-time, and in this case the type of $y$ can not be determined at compile time, which disagrees with the premise mentioned before. % What why?

% \begin{verbatim}
%   var typeX:Type := Int
%   let y:typeX := 4
% \end{verbatim}

% Different solutions for this problem have been considered, one way of doing it is to disallow mutable meta type. This solution insures that the meta type can't change at run-time, and there for the type can be determined at compile time. Another way of achieving compile time checking, is to disallow a variable to be type declared using a meta type. Due to a goal of having decent orthogonality in the language, it has been decided to not implement any kind of meta type. This solution ensures that there will be no confusion about how a meta type can be declared and no to be declared.
% In \cref{sub:constructionOfAnActor} it is described, how it is possible to spawn an actor without the use of any meta type.
