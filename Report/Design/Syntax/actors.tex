\subsection{Actors}

\kanote{hvis vi har variable actors, skal spawn beskrivelsen ændres}

% Actors inde i actors, nested, ejerskab, synlighed.
% Hvad gør kill? er det instantly? efter køen er kørt færdig?
% blocking vs. non-blocking messages? hvordan skelnes de? skal vi have begge?

\subsubsection{Isolation and Independence}

A central principle in the programming language described in this report is the use of actors, based on actor-modelling. Actors are to be seen as entities with interaction. In other words, in order for a construct to qualify as an actor, it must define a way to behave when other actors interact with it. Actors should function independently, and in that regard, not be open to direct manipulation and only able to be changed through the messages it receives. This requirement is due to the wish of separation of processes, which will allow for greater concurrency by letting processes operate on local data instead of global, shared data. Therefore TLDR tries to encourage natural isolation of functionality through actors, which in turn will also give a greater control of race conditions as no data is ever accessed by more than one process.

\subsubsection{Construction of an Actor}
\label{sub:constructionOfAnActor}

The syntactical construction of an actor is as follows:

\begin{lstlisting}
actor <identifier> := {
  <functionality>
}
\end{lstlisting}

And a concrete example could be:

\begin{verbatim}
  actor earth := {
    var temperature:real := 0;
    receive sunlight:light := {
      temperature := temperature + 0.1;
    }
  }
\end{verbatim}

As shown, the actor keyword precedes the definition, denoting the meaning of said definition. After the keyword an identifier of the construct is needed, which will serve as the of type the actor. It is suggested that this identifier reflects the role of the actor in a context of use. Noticeably there is no \enquote{let} or \enquote{var} keyword in front of the definition, as there usually is when assigning. This is a deliberate choice since \enquote{let} and \enquote{var} implies interchangeability, which is not an option is this case. If variable declaration of actor definitions were possible, it would effectively be the equivalent of changing the definition of a type on run-time, which would make little sense, and completely undermine the type safety.

Some general semantics of actors:

\begin{align*}
&\inference[TYPEOF]{}
                  {e \vdash m \Rightarrow_T t}
									{, \mathbb{T}(m) = t}
\\\\
&\inference[$\text{ACTOR}$]{a' = a[\Tact \mapsto e \times st]}
                           {\Braket{\Tactor \Tact := \{S\}, a} \Rightarrow_S \Braket{S,e,at[\Tact \mapsto S],a'}}
\\\\
&\inference[$\text{ACTOR}$]{}
                           {\Braket{\Tactor \Tact := 1S, at} \Rightarrow_S \Braket{at[\Tact \mapsto S]}}
\end{align*}

\subsubsection{Basic actor functionality}

There are four basic functionalities: \enquote{spawn}, \enquote{die}, \enquote{send}, and \enquote{receive}, which are all used through keywords. It was desired to keep the syntax of these functionalities different from the syntax of functions. Even though they behave much like functions, taking input and giving output, they are more powerful. Regular functions cannot contain a type as a parameter, but the \enquote{spawn} functionality does this. Due to these and more differences, which follows below, we decided to separate them syntactically. Actors can also reference themselves with the \enquote{me} keyword.

The \enquote{spawn} functionality is used to create new instances of actors. And example could be:

\label{actorfuncSpawn}
\begin{lstlisting}
actor <identifier> := {
 <functionality>
}

MyActor:<identifier> := spawn <identifier> <message>;
\end{lstlisting}

As can be seen above, there are four parts of a spawn functionality: an identifier, the keyword, type of actor, and possibly a message. Firstly the identifier is not preceded by a keyword for mutability, such as \enquote{let} or \enquote{var}. This is left out as the only allowed one would be \enquote{let} and putting that there would imply interchangeability. The reason for the restriction, of not having variable actors, is to stay true to the principle of interaction solely through messages, and by this avoid another degree of race conditions. Changing an actor while there are messages in the queue, would either require a flush of possibly crucial messages, or an unintended evaluation of a message. When spawning a new actor, you can also choose to add a message. The reason for this is to give the programmer a way of initialising the new actor with a certain message. In object-oriented languages this is usually done with a constructor, however including this would conflict with a central principle, since it would be a manipulation of an actor without a message.

The semantics of \enquote{spawn} is as follows:

\begin{align*}
&\inference[$\text{SPAWN}$]{}
                       {\Braket{\Tlet \Tact:T := \Tspawn \; T \Tm,\Ta} \Rightarrow_S \Braket{\Tsend \Tact \Tm,\Ta[act \mapsto e \times st]}}
\\
&												{, \Ta(x) \mapsto \Braket{S,p} , \Ta' = \Ta[\Tact \mapsto \Braket{S, p}]}
\end{align*}


%beskeder sent til sig selv, behandles på lige fod med andre beskeder.
After an actor has been spawned, it will be possible to send messages to it. This is done with the \enquote{send} keyword. This could be done as follows:

\label{actorfuncSend}
\begin{lstlisting}
MyMsg:int := 42;

Send MyActor MyMsg;
\end{lstlisting}

\kanote{skriv om 'send'}

The semantics of \enquote{send} is as follows:

\begin{align*}
&\inference[$\text{SEND}$]{e_2 = a(act),m \Rightarrow_T t}
                       {\Braket{\Tsend \Tact \Tm ; S,\Ta,e_1} \Rightarrow_S \Braket{S,e_1,a}|\Braket{\_t(m),e_2,a}}
\end{align*}

When an actor is sent a message, it must act according to a defined a way of handling that type of message. This definition is declared with the \enquote{receive} keyword, and can be seen below:

\label{actorfuncReceive}
\begin{lstlisting}
actor <nameOfActor> := {
 receive <nameOfMessage>:<typeOfMessage> := {
  <functionality>
 }
}
\end{lstlisting}

In this example the receive defines the way messages of the type \enquote{<typeOfMessage>} are handled. Within the functionality \enquote{<nameOfMessage>} is the reference to the message, and this message is immutable no matter if it was mutable where it was sent from. This is done to discourage further use of old messages.

The semantics of \enquote{receive} is as follows:

\begin{align*}
&\inference[$\text{RECEIVE}$]{}
                           {\Braket{\Treceive r:t := \{S\};,e} \Rightarrow_S \Braket{e[\_t \mapsto \Braket{S,r}]}}
\end{align*}

When an actor is no longer needed, it is possible to discard it with the \enquote{die} keyword. As opposed to other languages where \enquote{die} is called by a parent, that is the actor that spawned the actor, \enquote{die} can only be called by the actor itself. This is done in order to keep the principle of only having actors react to messages.


\subsubsection{Main is an Actor}

Main is always the first actor, and any program writtin in TLDR is started with main receiving the arguments message. This is done for multiple reasons. Foremost, having main behaving like an actor, better supports the actor modelling perspective.

\kanote{main er en actor. Beskriv plz}

\begin{align*}
&\inference[$\text{MAIN}$]{input \mapsto \Braket{S,\epsilon}}
                          {\Braket{\Treceive \Tr:args := \{S\};,e} \Rightarrow_S \Braket{\Tr := input;S, e]}}
\end{align*}