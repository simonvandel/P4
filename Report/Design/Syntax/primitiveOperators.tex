\subsection{Primitive Operators}
\label{subsec:primitiveOps}

Primitive operations are the operations that are build into the language.

\subsubsection{Mathematical Operators}
\label{sec:mathOps}

The following mathematical operations are built into the language.

\begin{itemize}
  \item \textbf{+} A binary operator that adds two numbers of the same type
  \item \textbf{-} A binary operator that subtracts two numbers of the same type
  \item \textbf{/} A binary operator that divides two numbers of the same type
  \item \textbf{\%} A binary operator that returns the remainder of a floored division of two numbers of the same type
  \item \textbf{\^}  A binary operator that lifts the first number to the power of the second number
  \item \textbf{\#} A binary operator that roots the first operand to the second operand
\end{itemize}

\sinote{Vi skal nok forklare hvilke nummer typer der kan plusses sammen osv.}

%\subsubsection{Arithmetic Expressions}
\newcommand{\Twedge}{\mathbin{^\wedge{}}}

\begin{align*}
&\inference[NUM]{}
                  {e \vdash n \Rightarrow_A v}
                  {, \mathcal{N}(n) = v}
\\\\
&\inference[$\text{INVOKE}_{A1}$]{\Braket{S,e} \Rightarrow_A v}
                  {\Braket{p,e} \Rightarrow_A v}
                  {,e(p) = \Braket{S,\epsilon}}
\\\\
&\inference[$\text{INVOKE}_{A2}$]{\Braket{S_1,e[p_1' \mapsto \Braket{S_2,p_2'}]} \Rightarrow_A v}
                  {\Braket{p_1(p_2),e} \Rightarrow_A v}
\\                  
&                 {,e(p_1) = \Braket{S_1,p_1'}, e(p_2) = \Braket{S_2,p_2'}}
\\\\
&\inference[$\text{PARENS}_\text{A}$]{e \vdash a_1 \Rightarrow_A a_1'}
                       {e \vdash (a_1) \Rightarrow_A (a_1')}
&
&\inference[$\text{PARENS}_\text{V}$]{}
                       {(v) \Rightarrow_A v}
\\\\
&\inference[$\text{ADD}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash  a_1 + a_2 \Rightarrow_A a_1' + a_2}
&
&\inference[$\text{ADD}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 + a_1 \Rightarrow_A a_2 + a_1'}
\\\\
&\inference[$\text{ADD}_\text{V}$]{}
                    {v_1 + v_2 \Rightarrow_A v}
                    {, v_1 + v_2 = v}
\\\\
&\inference[$\text{SUB}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 - a_2 \Rightarrow_A a_1' - a_2}
&
&\inference[$\text{SUB}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 - a_1 \Rightarrow_A a_2 - a_1'}
\\\\
&\inference[$\text{SUB}_\text{V}$]{}
                    {v_1 - v_2 \Rightarrow_A v}
                    {, v_1 - v_2 = v}
\end{align*}
\begin{align*}
&\inference[$\text{MULT}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                     {e \vdash a_1 * a_2 \Rightarrow_A a_1' * a_2}
&
&\inference[$\text{MULT}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                     {e \vdash a_2 * a_1 \Rightarrow_A a_2 * a_1'}
\\\\
&\inference[$\text{MULT}_\text{V}$]{}
                     {v_1 * v_2 \Rightarrow_A v}
                     {, v_1 * v_2 = v}
\\\\
&\inference[$\text{DIV}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 / a_2 \Rightarrow_A a_1' / a_2}
&
&\inference[$\text{DIV}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 / a_1 \Rightarrow_A a_2 / a_1'}
\\\\
&\inference[$\text{DIV}_\text{V}$]{}
                    {v_1 / v_2 \Rightarrow_A v}
                    {, \frac{v_1}{v_2} = v}
\\\\
&\inference[$\text{MOD}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 \% a_2 \Rightarrow_A a_1' \% a_2}
&
&\inference[$\text{MOD}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 \% a_1 \Rightarrow_A a_2 \% a_1'}
\\\\
&\inference[$\text{MOD}_\text{V}$]{}
                    {v_1 \% v_2 \Rightarrow_A v}
                    {, v_1 \;\; \textrm{mod} \;\; v_2 = v}
\\\\
&\inference[$\text{POW}_\text{L}$]{e \vdash a_1  \Rightarrow_A a_1'}
                    {e \vdash a_1 \Twedge a_2 \Rightarrow_A a_1' \Twedge a_2}
&
&\inference[$\text{POW}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 \Twedge a_1 \Rightarrow_A a_2 \Twedge a_1'}
\\\\
&\inference[$\text{POW}_\text{V}$]{}
                    {v_1 \Twedge v_2 \Rightarrow_A v}
                    {, v_1 ^ {v_2} = v}
\\\\
&\inference[$\text{ROOT}_\text{L}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_1 \# a_2 \Rightarrow_A a_1' \# a_2}
&
&\inference[$\text{ROOT}_\text{R}$]{e \vdash a_1 \Rightarrow_A a_1'}
                    {e \vdash a_2 \# a_1 \Rightarrow_A a_2 \# a_1'}
\\\\
&\inference[$\text{ROOT}_\text{V}$]{}
                    {v_1 \# v_2 \Rightarrow_A v}
                    {, \sqrt[v_1]{v_2} = v}
\end{align*}

\paragraph{Logical Operations}
\label{sec:logicOps}

\begin{itemize}
  \item \textbf{=} A binary operator that compares the two operands for equality. Returns true if equal. False otherwise.
  \item \textbf{!=} A binary operator that compares the two operands for equality. Returns true if not equal. False otherwise.
  \item \textbf{<} A binary operator that compares the two operands. Returns true if the first operand is strictly less than the second operand. False otherwise.
  \item \textbf{<=} A binary operator that compares the two operands. Returns true if the first operand is less than or equal to the second operand. False otherwise.
  \item \textbf{>} A binary operator that compares the two operands. Returns true if the first operand is strictly greater than the second operand. False otherwise.
  \item \textbf{>=} A binary operator that compares the two operands. Returns true if the first operand is greater than or equal to the second operand. False otherwise.
\end{itemize}

\paragraph{Boolean Operations}
\label{sec:boolOps}

The following operations only operate on bool types.

\begin{itemize}
  \item \textbf{AND} A binary operator that returns true if both values are true. False otherwise
  \item \textbf{OR} A binary operator that returns true if at least one value is true. False otherwise
  \item \textbf{XOR} A binary operator that returns true if only one operand is true. False otherwise
  \item \textbf{NOR} OR negated.
  \item \textbf{NOT} A unary operator that returns the opposite value of the operand.
  \item \textbf{NAND} A binary operator that returns true if none or a single operand is true. False otherwise
\end{itemize}