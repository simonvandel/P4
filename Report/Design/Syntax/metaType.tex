\subsection{Meta type}
\label{sub:meta_type}

It has been decided to design the language in a manner that insures that all type checking can be done at compile time. To insures this; all identifiers must have explicit type declaration.
A meta type is in this report defined as a type which can be an instance of any other type in the language. %Expand on this
The functionally which spawns a new actor needs to know of which type the actor should be of, in this case a meta type would be useful to describe the actual type of the actor.
So to imagine a meta type in this language, it would look something like this: %Bad language and not very academic

\begin{verbatim}
  let x:Type := Int
\end{verbatim}

In fact $typeX$ is just a placeholder for a type, the following expression should evaluate to int and the declaration of $y$ would be fine. %Fine? Correct?
But notice that type is declared using the var keyword which makes an variable mutable. %Rephrase
If $typeX$ is mutable it can change state doing run-time, and in this case the type of $y$ can not be determined at compile time, which disagrees with the premise mentioned before. % What why?

\begin{verbatim}
  var typeX:Type := Int
  let y:typeX := 4
\end{verbatim}

Different solutions for this problem have been considered, one way of doing it is to disallow mutable meta type. This solution insures that the meta type can't change at run-time, and there for the type can be determined at compile time. Another way of achieving compile time checking, is to disallow a variable to be type declared using a meta type. Due to a goal of having decent orthogonality in the language, it has been decided to not implement any kind of meta type. This solution ensures that there will be no confusion about how a meta type can be declared and no to be declared.
In \cref{sub:constructionOfAnActor} it is described, how it is possible to spawn an actor without the use of any meta type.
