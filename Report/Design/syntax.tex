\section{Syntax}
\label{sec:syntax}

\subsection{Primitive Data Types}
\label{subsec:primitives}

A primitive is a predefined value type that cannot be constructed using other value types.

The following primitives exist in the language. All primitives are lower-cased.

\begin{itemize}
  \item int
  \item real
  \item bool
  \item char
  \item unit/void/empty \sinote{bliv enige om navn. Skal rettes længere nede også}
\end{itemize}

\subsubsection{Integer}
\label{subsubsec:int}

The int primitive can have values of 0 to \sinote{hvor mange bits?}. The int primitive's literal representation is as whole numbers e.g. \enquote{2}.

\subsubsection{Real}
\label{subsubsec:real}

The real primitive can have values of \sinote{hvordan definerer vi det her?}. The real primitive's literal representation is as decimal numbers with fractions e.g. \enquote{2.5} or \enquote{2.0}.

\subsubsection{Bool}
\label{subsubsec:bool}

The bool primitive's value can be either \enquote{true} or \enquote{false}.

\subsubsection{Char}
\label{sec:char}

The char primitive can have values of the ASCII standard. It is written literally as a character defined in the ASCII standard, surrounded by single quotation marks. For example: \enquote{ '0' } and \enquote{ 'A' }.

\subsubsection{Unit/void/empty}
\label{sec:unit/empty/void}

The unit/void/empty primitive can have only one value: itself. The use of the primitive is to signal emptiness.

\subsection{Primitive Operators}
\label{sec:primitiveOps}

Primitive operations are the operations that are build into the language.

\subsubsection{Mathematical Operators}
\label{sec:mathOps}

The following mathematical operations are built into the language.

\begin{itemize}
  \item \textbf{+} A binary operator that adds two numbers of the same type
  \item \textbf{-} A binary operator that subtracts two numbers of the same type
  \item \textbf{/} A binary operator that divides two numbers of the same type
  \item \textbf{\%} A binary operator that integer divides two number of the same type and returns the remainder
  \item \textbf{\^}  A binary operator that lifts the first number to the power of second number
  \item \textbf{root} A binary operator that roots the first value to second value
\end{itemize}

\sinote{Vi skal nok forklare hvilke nummer typer der kan plusses sammen osv.}

\subsubsection{Logical Operations}
\label{sec:logicOps}

\begin{itemize}
  \item \textbf{=} A binary operator that compares the two values for equality. Returns true if equal. False otherwise.
  \item \textbf{!=} A binary operator that compares the two values for equality. Returns true if not equal. False otherwise.
  \item \textbf{<} A binary operator that compares the two values. Returns true if first value is strictly less than second value. False otherwise.
  \item \textbf{<=} A binary operator that compares the two values. Returns true if first value is less than or equal to second value. False otherwise.
  \item \textbf{>} A binary operator that compares the two values. Returns true if first value is strictly greater than the second value. False otherwise.
  \item \textbf{>=} A binary operator that compares the two values. Returns true if first value is greater than or equal to the second value. False otherwise.
\end{itemize}

\subsubsection{Boolean Operations}
\label{sec:boolOps}

The following operations only operate on bool types.

\begin{itemize}
  \item \textbf{AND} A binary operator that returns true if both values on both sides are true. False otherwise
  \item \textbf{OR} A binary operator that returns true if one value on either sides are true. False otherwise
  \item \textbf{XOR} Same as \textbf{OR}, but in the case that both sides are true, returns also false.
  \item \textbf{NOT} Negates the boolean value
  \item \textbf{NAND} Same as NOT (<bool1> AND <bool2>)
\end{itemize}

\subsection{Functions}
\label{sec:functions}

Functions can be declared in two ways. By separating the type signature and the function body or by combining the signature and the function body.

\paragraph{Separated function declaration}

The syntax for the separated function declaration is as follows. The type signature and the body must be declared in the same lexical scope.

\begin{verbatim}
  <funcName> : <typeSignature>
  let <funcName>(<parameterList>) := {<body>}
\end{verbatim}

A concrete example:

\begin{verbatim}
  plus : int -> int -> Int
  let plus(x, y) := {x + y}
\end{verbatim}


\paragraph{Combined function declaration}

The syntax for the combined function declaration is as follows.

\begin{verbatim}
  let <funcName>(<parameterList>) : <typeSignature> := {<body>}
\end{verbatim}

A concrete example:

\begin{verbatim}
  let plus(x, y) : Int -> Int -> Int := {x + y}
\end{verbatim}

\subsection{Comments}
\label{sec:comments}

Text only relevant to the reader of a piece of code is called a comment. Comments therefore has no meaning to the parser and is ignored. Comments are declared in C style by \enquote{//} being a single line comment and \enquote{/**/} being a multi line comment.

A concrete example:

\begin{verbatim}
  // this is a single line comment
  /* this is
     a
     multi line comment */
\end{verbatim}

\subsection{Value Assignment}
\label{sec:value_assignment}

A value can be assigned to a symbol in either a constant binding or a variable binding. 

\paragraph{Constant Binding}

A constant binding can never have its value changed. For example, if \enquote{a} is bound to \enquote{5}, \enquote{a} can never refer to another value than \enquote{5} in the same lexical scope.

The syntax for constant value assignment is as follows.
\begin{verbatim}
  let <symbolName> : <type> := <value>
\end{verbatim}

A concrete example:

\begin{verbatim}
  let x : int := 2
\end{verbatim}

\paragraph{Variable Binding}

A variable binding can always change the value it refers to. For example, if \enquote{b} is bound to \enquote{2}, it is perfectly possible to later in the source code refer to {10}.

The syntax for variable value assignment is as follows.
\begin{verbatim}
  var <symbolName> : <type> := <value>

  // a later reassignment
  <symbolName> := <value>
\end{verbatim}

A concrete example:

\begin{verbatim}
  var a : int := 2
  
  // a later reassignment
  a := 2
\end{verbatim}

\subsection{Structures}
\label{sec:structs}

\subsubsection{Defining Structures}
\label{sec:defStructures}

Structures are defined by using the \enquote{struct} keyword. 

\begin{verbatim}
  struct <structName> := {<structFields>}
\end{verbatim}

A concrete example:

\begin{verbatim}
  struct Person := {Name:[char]; Age:int}
\end{verbatim}

\subsubsection{Initialising Structures}
\label{sec:initStructures}

Structs can be initialised and assigned to symbols using either a constant assignment or a variable assignment. Structs initialised as a constant assignment cannot change any of the fields of the structs; the struct is immutable. Structs initialised as a variable assignment can change all of its fields at any time; the struct is mutable.

The syntax for initialising an immutable struct is as follow.

\begin{verbatim}
  let Alice:Person := {Name := "Alice"; Age := 20};
\end{verbatim}

The syntax for initialising a mutable struct is as follow.

\begin{verbatim}
  var Alice:Person := {Name := "Alice"; Age := 20};
\end{verbatim}

\subsubsection{Access to Structure Fields}
\label{sec:accessStructFields}

Fields can be access using the following syntax.

\begin{verbatim}
  Alice.Name; // "Alice"
\end{verbatim}

Structs declared as mutable can have fields reassigned using the following syntax.

\begin{verbatim}
  Alice.Name; // "Alice"
  Alice.Name := "Bob";
  Alice.Name; // "Bob";
\end{verbatim}

\subsection{For-loop Statements}
\label{sec:forLoopStatements}

There are three for-loop statements defined in the language. A traditional C for-loop, a for-in loop and a variation of the for-in loop where both the index and the element of the collection being looped is provided.

\subsubsection{C Inspired For-loop}
\label{sec:cForLoop}

The syntax for the first for-loop variation is defined below.

\begin{verbatim}
  for(<startValue>; <condition>; <updateStatement>) {<loopBody>};
\end{verbatim}

A concrete example:

\begin{verbatim}
  for(int i := 0; i < 10; i++) {/* Do stuff */}
\end{verbatim}

\subsubsection{For-in loop}
\label{sec:forInLoop}

The for-in loop statement has the following syntax.

\begin{verbatim}
  for <element> in <collection> {<loopBody>}
\end{verbatim}

A concrete example:

\begin{verbatim}
  for i:int in [0..10]:[int] { /* Do stuff with i elements */ }
\end{verbatim}

\subsubsection{For-in loop with index}
\label{sec:forInLoopIndex}

A variation of the for-in loop that also provides the index of the current element, has the following syntax.

\begin{verbatim}
  for (<index>, <element>) in <collection> {<loopBody>}
\end{verbatim}

A concrete example:

\begin{verbatim}
  for (index:int, elem:int) in [0..10]:[int] { /* Do stuff with i elements and index */ }
\end{verbatim}