%mainfile: ../master.tex

\section{Target Language}
\label{sec:targetLanguage}

The target language is the language that the compiler translates the source language into. In this section the choice of target language will be described.

\subsection{Choice of Target Language}

Different language types were considered as the target language of choice: assembly languages such as Java bytecode, CLI and LLVM IR, and languages just a level higher than assembly languages, such as C.

Languages with higher levels of abstractions were not an opportunity because the authors of this report did not want to create a \enquote{search-and-replace} compiler. Such a compiler could for example translate a \emph{until} construct in a language to the \emph{while} loop of C. Such a compilation was deemed too trivial for the academic context of this project. 

The following target languages were considered:

\subsubsection{C}
C is the only high level language considered, because of its complexity, due to the the lack of memory management. C has a lot of libraries, is a well known language and is more readable by humans than an assembly language. C was not chosen because C compilers interpret data types in different ways on different platforms, meaning program correctness is dependent on the platform it is run on.

\subsubsection{Java Bytecode}
Java bytecode runs on any Java Virtual Machine (JVM), which makes the language highly cross-platform. Java bytecode is a instruction and stack based language. Because of its maturity lots of documentation is available. Java bytecode has large set of framework and libraries, because many languages run on the JVM. Many popular implementations exist for the actor model; for example Akka. Scala and Clojure are both examples of languages built upon the JVM. Many implementations of JVMs support garbage collection. Java bytecode was not chosen as the language of choice because its strong connection to the object oriented paradigm. A more paradigm neutral language is preferred, in order to not taint the design of TLDR.

\subsubsection{Common Intermediate Language}
Common Intermediate Language (CIL) is an intermediate language, C\#, F\# and many more languages target. Common Intermediate Language and Common Language Infrastructure (CLI) have many things in common with Java bytecode and the JVM, including support for garbage collection. The specification for CLI is open, so implementations can be made for many platforms. Microsoft has implemented its own CLI implementation called .NET Framework. Support for Linux is given by the Mono implementation. CIL was not chosen for the same reasons as Java bytecode.

\subsubsection{LLVM}
LLVM is a register and instruction based language very similar to other assembly languages, such as X86. Register allocation is handled automatically, so arbitrarily many registers can be used in LLVM IR source language. LLVM has support for both explicitly freeing memory and in recent versions gained support for garbage collection hooks. The language reference is very comprehensive and easily understood. LLVM has a large set of libraries which are compatible, because many languages can be compiled to LLVM IR. Frontend compilers to LLVM exist for C, C++, Java and many others. LLVM IR is compiled to machine code for architectures that have a LLVM backend written for it.

\subsubsection{Final Choice}
LLVM was chosen because of its many libraries and very good documentation. It also has a lot in common with x86 assembly which the group has had prior experience with.
