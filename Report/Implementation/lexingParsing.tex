\section{Lexing \& Parsing}

The lexing and parsing part of the compiler is written using the Hime parser generator, as described in \cref{sec:compiler_compiler_choice}. This chapter describes the features supported by Hime and its uses in the compiler.

\subsection{Tree Transformations}
\label{sec:tree_transformations}

The output of running Hime on a grammar is a syntax tree. By default the output syntax tree matches the grammar rules one-to-one. That is, the syntax tree is a concrete syntax tree (CST). In the later stages of the compiler, many nodes of the CST are unneeded. \Cref{fig:indirection_example} lists two types of nodes, not needed in the final abstract syntax tree (AST), adding an extra layer of indirection and altogether superfluous nodes.

\begin{lstlisting}[caption={Starting example grammar}, label={fig:indirection_example}]
  A -> ( B )
  B -> C
\end{lstlisting}

\Cref{fig:indirection_example} corresponds to the CST seen in \cref{fig:cst_example}.

\begin{figure}[hbtp]
\centering
\caption{CST without tree transformations. \label{fig:cst_example}}
\begin{tikzpicture}
\tikzset{level distance=30pt,sibling distance=20pt}
\Tree [.A [.( ] [ .B C ] [ .) ] ]
\end{tikzpicture}
\end{figure}

In \cref{fig:cst_example}, the node \emph{B} is not needed as it is simply an alias for \emph{C}. It would be preferable to just have \emph{A} as the root, with \emph{C} as a child of \emph{A}, in the final syntax tree to be used in later compiler phases. In addition, the parentheses do not add any information to the final syntax tree. The desired AST can be seen in \cref{fig:wanted_ast}.

\begin{figure}[hbtp]
\centering
\caption{The desired AST. \label{fig:wanted_ast}}
\begin{tikzpicture}
\tikzset{level distance=30pt,sibling distance=20pt}
\Tree [.A [ .C ] ]
\end{tikzpicture}
\end{figure}

To solve these two problems, the promote and drop actions can be utilised.

\subsubsection{Promote Action}

The promote action, when applied to a node, replaces its parent node with itself, thereby becoming the new parent node.

The promote action can be applied to \emph{C} in \cref{fig:cst_example} as seen in \cref{fig:indirection_example_promote} to achieve the desired AST.

\begin{lstlisting}[caption={Applying a promote action to the grammar}, label=fig:indirection_example_promote]
  A -> ( B )
  B -> C^
\end{lstlisting}

\begin{figure}[hbtp]
\centering
\caption{The result of applying the promote action to \emph{C}. \label{fig:ast_promote}}
\begin{tikzpicture}
\tikzset{level distance=30pt,sibling distance=20pt}
\Tree [.A [.( ] [ .C ] [ .) ] ]
\end{tikzpicture}
\end{figure}

\subsubsection{Drop Action}

The drop action removes the node it is applied to, and all of its children, entirely from the syntax tree. This can be utilised in \cref{fig:ast_promote} to remove the two parentheses that have no meaning to the compiler. Continuing from the result of applying the promote action, the drop action can be applied to the parentheses as seen in \cref{fig:indirection_example_drop}.

\begin{lstlisting}[caption={Applying a drop action to grammar},label=fig:indirection_example_drop]
  A -> (! B )!
  B -> C
\end{lstlisting}

\begin{figure}[hbtp]
\centering
\caption{The result of applying the drop action to \emph{(} and \emph{)}. \label{fig:ast_promote}}
\begin{tikzpicture}
\tikzset{level distance=30pt,sibling distance=20pt}
\Tree [.A [ .C ] ]
\end{tikzpicture}
\end{figure}

Using both the promote and drop actions, the CST has been transformed into an AST with only the relevant information in it.

\subsection{Improving AST Representation}

The feature of tree transformations allow for stripping a CST to a AST, as described in \cref{sec:tree_transformations}. The Hime AST generated by applying tree transformations contains all the information needed for later phases of the compiler. However, every node in the AST is \enquote{stringly typed}, meaning that every information is encoded as strings. While containing the information, a more optimal and safe encoding can be made using the discriminated union feature of F\#. It would be ideal to convert the stringly typed Hime AST to a AST with different types encoding different language constructs. By doing this conversion, the AST can be described more precise by using types that the F\# compiler can statically verify are being used correctly, hereby avoiding a large range of potential implementation bugs in the compiler described in this project.

To do this conversion from the Hime AST to the more optimal typed representation, a function, \enquote{toAST}, converts every known node string representation to the stronger typed wanted representation.