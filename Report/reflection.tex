\chapter{Reflection}{Intro}\label{chapter:reflection}

During the development of TLDR there has been several crossroads that had major impacts on the direction of the language. This chapter will intail our refleksions on what could have been done differently, and how it might have changed the development of the language.

This is the first language which the group members have worked with and so a lot of decision was made without experience. We feel like this resulted in decisions which seemed right, but turned out to have ripple effects which we did not forsee. One such choice was the omittance of a null value. This was wanted, since we wanted TLDR to not require nullchecks unless specified. This decision caused TLDR to require the programmer to assign a value whenever something was declared. Later this proved problematic since certain common usages of actors would require you spawn an actor, only to kill it immediatly, if all you wanted was a handle. And the problem was still around, since an actor could still send messages to actors whom where killed, which essentially is a null reference. This choice and thereby the revertion could probably have been avoided, if the group had had more experience with language design.

The language design process was done democratically, with voting where we could not reach an agreement. Sometimes this process resulted in a compromise between two ideas, since this seemed most fair. However, as we have learned, language design should not be about fairness for the developers, but what is best for the language. And even though all the ideas might have worked in their own regard, a mix of different ideas usually just turn out to be two halfway working functionalities, and a loss of the principles behind the idea in the first place. In any future language design project the group member will end up in, we will better understand the importance of having a truely united direction for the language.

During the design process it also became obvious to us, just how subjective the quality of a language can be. Two group members might have discussed the inclusion of a feature in the language, argumenting for and against, only to find out that they wanted to improve readability, but had different ideas of what makes a language readable. If we were to develop further on TLDR, we would probably try and gather a focus group matching the target audience of the language, since it would ultimately be their opinion which counts.

TLDR was developed with the waterfall design method. This method (or at least a sequencial) was nessesary due to the progression of the semester courses. Even so, a couple of aspects of the development process is worth some reflection as to what would have been different, had we followed an iterative design method. But first a few consequences of the chosen model.

The waterfall method works well with language design on the point of language principles. If the design of the language is done without much thought as to the implementation, the language will be more true to the principles, and cut less corners due to hardship during implementation. This is great since it allows for pure design, as long as the design ideas are not directly impossible to implement. Some language pricniples does however require implementation to be into consideration, but you are of course free to do so. The method can due to this freedom, potentially increase the difficulty of implementing a compiler which will compile the language. In addition, some features might seem like a good idea during language design, but might be less desirable by the programmer than expected.

So what could have happened with an iterative design method? Likely an iterative process would have been better for discovering design flaws earlier, allowing programs to be written in the language earlier albeit with a limited set of features. Writing more in the language could also have given a better idea of which features were important from a programmers perspective. Iterative methods would also better allow for testing which construct are possible to implement, before the decision is set in stone. In hindsight, an iterative design method, would probably be prefered.


