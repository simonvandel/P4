\chapter{Reflection}\label{chapter:reflection}

During the development of TLDR there has been several crossroads that had major impacts on the direction of the language. This chapter will intail some reflections on what could have been done differently, and how it might have changed the development of the language.

\section{Decisions Without Experience}

This is the first language the group members have developed, so a lot of decisions were made without the wisdom of experience. Many times this resulted in decisions which seemed right at forst, but turned out to have ripple effects which were not foreseen. One such choice was the omittance of a null value. This was wanted, since we wanted TLDR to not require checks for the null value every time a variable was being used. This decision caused TLDR to require the programmer to assign a value whenever something was declared. Later this proved problematic since certain common usages of actors would require you to spawn an actor, only to kill it immediately, if all you wanted was a handle, generating a massive overhead. Even when doing so, the null problem was still around, since an actor could still send messages to actors whom where killed, which essentially is a null reference. This choice and thereby the reversion could probably have been avoided, if the group had had more experience with language design.

\section{Language Design Process}

The language design was done democratically, with voting where we could not reach an agreement. Sometimes this process resulted in a compromise between two ideas, since this seemed most fair. However, as we have learned, language design should not be about fairness for the developers of the language, but what is best for the language. And even though all the ideas might have worked in their own regard, a mix of different ideas may very well turn out to be two halfway working functionalities, and a loss of the principles behind the idea in the first place. In any future language design project the group members might end up in, we will better understand the importance of having a truly united direction for the language.

During the design process it also became obvious to us, just how subjective the quality of a language can be. Two group members might have discussed the inclusion of a feature in the language, arguing for and against, only to find out that they wanted to improve readability, but had different ideas of what makes a language readable. If we were to develop further on TLDR, we would probably try and gather a focus group, matching the target audience of the language, since it would ultimately be their opinion that counts.

TLDR was developed with the waterfall design method. This method, or at least a sequential design method, was necessary due to the progression of the semester courses. Even so, a couple of aspects of the development process is worth some reflection as to what would have been different, had we followed an iterative design method. But first, a few consequences of the chosen model.

The waterfall method works well with language design on the point of language principles. If the design of the language is done without much thought as to the implementation, the language will be more true to the principles, and cut less corners due to hardship during implementation. This is great, since it allows for pure design, as long as the design ideas are not directly impossible to implement. The method can due to this freedom, potentially increase the difficulty of implementing a compiler which will compile the language. In addition, some features might seem like a good idea during language design, but might be less desirable by the programmer than expected.

So what could have happened with an iterative design method? Likely an iterative process would have been better for discovering design flaws earlier, allowing programs to be written in the language earlier albeit with a more limited set of features. Writing more in the language could also have given a better idea of which features were important from a programmers perspective. An iterative method would also better allow for testing which constructs were possible to implement, before the decision is set in stone. In hindsight, an iterative design method, would probably be preferred.
