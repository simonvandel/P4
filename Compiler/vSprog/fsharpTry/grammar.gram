grammar vSprogGrammar{

  options{
    Axiom         = "Program";
    Separator     = "SEPARATOR";
  }

  terminals{
    NEW_LINE      -> U+000D | U+000A | U+000D U+000A | U+2028 |  U+2029;
    WHITE_SPACE   -> U+0020 | U+0009 | U+000B | U+000C;
    COMMENT_LINE  -> '//' (.* - (.* NEW_LINE .*)) NEW_LINE;
    COMMENT_BLOCK -> '/*' (.* - (.* '*/' .*)) '*/';
    SEPARATOR     -> (NEW_LINE | WHITE_SPACE| COMMENT_LINE | COMMENT_BLOCK)+;

    /*--------- Keywords ---------*/
    LET           -> 'let';
    WAIT          -> 'wait';
    ACTOR         -> 'actor';
    RECEIVE       -> 'receive';
    SEND          -> 'send';
    SPAWN         -> 'spawn';
    VAR           -> 'var';
    WHILE         -> 'while';
    FOR           -> 'for';
    IN            -> 'in';
    IF            -> 'if';
    STRUCT        -> 'struct';
    RETURN        -> 'return';
    PRIMITIVE     -> 'int' | 'real' | 'char' | 'bool';

    IDENTIFIER    -> [a-zA-Z_][a-zA-Z_0-9]*-(LET | VAR | PRIMITIVE | STRUCT | ACTOR | RECEIVE | SEND | SPAWN | WAIT | RETURN | FOR | IN | IF);

    /*--------- Symbols ---------*/
    EQUALS        -> '=';
    ASSIGN        -> ':=';
    LPARENS       -> '(';
    RPARENS       -> ')';
    STARTTUPLE    -> '<';
    ENDTUPLE      -> '>';
    LEADSTO       -> '->';
    COLON         -> ':';
    BLOCKSTART    -> '{';
    BLOCKEND      -> '}';
    TO            -> '..';
    DOT           -> '.';
    SEMICOLON     -> ';';
    STARTLIST     -> '[';
    ENDLIST       -> ']';
    COMMA         -> ',';

    PZEROOPERATOR -> '*' | '/' | '%';
    PONEOPERATOR  -> '+' | '-';

    /*--------- Numbers ---------*/
    INT           -> [1-9][0-9]* | '0'; 
    REAL          -> ([0-9]+'.'[0-9]+)|([0-9]+'.')|('.'([0-9])+); 

    /*--------- Chars ---------*/
    STRING        -> '"'[a-zA-Z_0-9]*'"';
    CHAR          -> '\''[a-zA-Z_0-9]|' ''\'';
  }

  rules{
    /*--------- Program ---------*/
    Program          -> Body^;

    Body             -> Body^ SEMICOLON! Line^
                      | Body^ SEMICOLON!
                      | Line^;

    Line             -> Expression^;

    /*--------- Expression ---------*/
    Expression       -> Assignment^
                      | Declaration^
                      | Operation^
		                  | Spawn^
                      | Receive^
                      | Return^
                      | Send^
                      | If^
                      | For^;
                      //| Match;

    Spawn            -> LET DecoratedID ASSIGN SPAWN IDENTIFIER Operation
    		              | VAR DecoratedID ASSIGN SPAWN IDENTIFIER Operation;

    Send	           -> SEND IDENTIFIER Operation;

    /*--------- Return ---------*/
    Return           -> RETURN Operation;

    /*--------- Wait ---------*/
    Wait             -> WAIT Types;

    /*--------- Receive ---------*/
    Receive          -> RECEIVE! DecoratedID ASSIGN! Block;

    /*--------- For ---------*/
    For              -> FOR Ids IN List Block;

    /*--------- If ---------*/
    If               -> IF Operation Block;

    /*--------- Block ---------*/
    Block            -> BLOCKSTART! Body BLOCKEND!
                      | BLOCKSTART! BLOCKEND!;

    /*--------- Operation ---------*/
    Operation        -> Operation PONEOPERATOR Factor
                      | Operation Logic Factor
                      | Factor^;
    Factor           -> Factor PZEROOPERATOR Term
                      | Term^;
    Term             -> Operand^
                      | LPARENS! Operation RPARENS!;
    Operand	         -> Block
                      | Integer^
            	        | Real^
        	            | IDENTIFIER
                      | IDENTIFIER Accessor
                      | Literals
                      | Invocation;

    Integer          -> INT;
    Real             -> REAL;

    Logic            -> EQUALS;

    Literals         -> STRING
                      | List
                      | Tuple;

    Invocation       -> IDENTIFIER LPARENS Ids? RPARENS;

    /*--------- Assignment ---------*/
    Assignment       -> Assignable ASSIGN! Operation;

    /*--------- Assignable ---------*/
    Assignable       -> DecoratedID
                      | IDENTIFIER Accessor;

    /*--------- Declaration ---------*/
    Declaration      -> Struct^
                      | Actor^
                      | Initialisation^
                      | TypeDecl^;

    Struct           -> STRUCT IDENTIFIER ASSIGN BLOCKSTART TypeDecls? BLOCKEND;
    TypeDecls        -> TypeDecls SEMICOLON TypeDecl
                      | TypeDecls SEMICOLON
                      | TypeDecl^;

    Actor            -> ACTOR! DecoratedID ASSIGN! Block;

    Initialisation   -> LET DecoratedID ASSIGN! Operation
                      | VAR DecoratedID ASSIGN! Operation;

    DecoratedID      -> IDENTIFIER LPARENS! Ids? RPARENS! COLON! Types
                      | TypeDecl^
                      | IDENTIFIER;

    Ids              -> IDENTIFIER COMMA Ids
                      | IDENTIFIER;
    TypeDecl         -> IDENTIFIER COLON! Types;

    /*-------- Type ---------*/
    Types            -> Types LEADSTO Type
                      | Type^;
    Type             -> PRIMITIVE
                      | IDENTIFIER
                      | STARTLIST Types ENDLIST
                      | LPARENS Types RPARENS;

    /*--------- List ---------*/
    List             -> STARTLIST ListParams ENDLIST;
    ListParams       ->	ListParams COMMA Operation
                      | Operation TO Operation
                      | Operation;

    /*--------- Tuple ---------*/
    Tuple            -> LPARENS Operations COMMA Operation RPARENS;
    Operations       -> Operations COMMA Operation
                      | Operation;

    /*--------- Accessor ---------*/

    Accessor         -> DOT IDENTIFIER
                      | DOT STARTLIST INT ENDLIST
                      | DOT IDENTIFIER Accessor;

    /*--------- ForLoop ---------*/
    //ForLoop          -> FOR LPARENS 'blabla' SEMICOLON expression SEMICOLON expression RPARENS ASSIGN Block
    //ForLoop          ->
  }
}
