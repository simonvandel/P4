grammar vSprogGrammar{

  options{
    Axiom             = "Program";
    Separator         = "SEPARATOR";
  }

  terminals{
    NEW_LINE         -> U+000D | U+000A | U+000D U+000A | U+2028 |  U+2029;
    WHITE_SPACE      -> U+0020 | U+0009 | U+000B | U+000C;
    COMMENT_LINE     -> '//' (.* - (.* NEW_LINE .*)) NEW_LINE?;
    COMMENT_BLOCK    -> '/*' (.* - (.* '*/' .*)) '*/';
    SEPARATOR        -> (NEW_LINE | WHITE_SPACE| COMMENT_LINE | COMMENT_BLOCK)+;

    /*--------- Keywords ---------*/
    LET              -> 'let';
    WAIT             -> 'wait';
    ACTOR            -> 'actor';
    RECEIVE          -> 'receive';
    SEND             -> 'send';
    SPAWN            -> 'spawn';
    VAR              -> 'var';
    WHILE            -> 'while';
    DIE              -> 'die';
    FOR              -> 'for';
    IN               -> 'in';
    IF               -> 'if';
    ELSE             -> 'else';
    STRUCT           -> 'struct';
    RETURN           -> 'return';
    PRIMITIVE        -> 'void' | 'int' | 'real' | 'char' | 'bool';

    IDENTIFIER       -> [a-zA-Z][a-zA-Z_0-9]*-(LET | VAR | PRIMITIVE | STRUCT | ACTOR | RECEIVE | SEND | SPAWN | WAIT | RETURN | FOR | IN | IF | ELSE | WHILE | DIE);

    /*--------- Symbols ---------*/
    ASSIGN           -> ':=';
    LPARENS          -> '(';
    RPARENS          -> ')';
    STARTTUPLE       -> '<';
    ENDTUPLE         -> '>';
    LEADSTO          -> '->';
    COLON            -> ':';
    BLOCKSTART       -> '{';
    BLOCKEND         -> '}';
    TO               -> '..';
    DOT              -> '.';
    SEMICOLON        -> ';';
    STARTLIST        -> '[';
    ENDLIST          -> ']';
    COMMA            -> ',';

    PZEROOPERATOR    -> '^' | '#';
    PONEOPERATOR     -> '*' | '/' | '%';
    PTWOOPERATOR     -> '+' | '-';
    PTHREEOPERATOR   -> '=' | '!=' | '<' | '<=' | '>' | '>=';
    PFOUROPERATOR    -> 'NOT';
    PFIVEOPERATOR    -> 'AND' | 'NAND';
    PSIXOPERATOR     -> 'OR' | 'XOR' | 'NOR' ;

    /*--------- Numbers ---------*/
    INT              -> '-'?[1-9][0-9]* | '0'; 
    REAL             -> ([0-9]+'.'[0-9]+)|([0-9]+'.')|('.'([0-9])+); 

    BOOL             -> 'true' | 'false';

    /*--------- Chars ---------*/
    STRING           -> '"'[a-zA-Z_0-9 !]*'"';
    CHAR             -> '\''[a-zA-Z_0-9 ]|' ''\'';
  }

  rules{
    /*--------- Program ---------*/
    Program          -> Body;

    Body             -> Body^ SEMICOLON! Expression
                      | Body^ SEMICOLON!
                      | Expression;

    /*--------- Expression ---------*/
    Expression       -> Declaration^
                      | Operation^
                      | Receive^
                      | Spawn^
                      | Return^
                      | Die^
                      | Send^
                      | If^
                      | IfElse^
                      | While^
                      | ForIn^;

    Spawn            -> (LET | VAR) TypeDecl ASSIGN! SPAWN! Identifier Operation?;

    Send	           -> SEND! Identifier Operation;

    /*--------- Return ---------*/
    Return           -> RETURN! Operation?;

    /*--------- Receive ---------*/
    Receive          -> RECEIVE! TypeDecl ASSIGN! Block;

    Die              -> DIE;

    /*--------- For ---------*/
    ForIn            -> FOR! Ids IN! (List| Identifier ) Block;

    /*--------- While ------*/
    While            -> WHILE! Operation Block;

    /*--------- If ---------*/
    If               -> IF! Operation Block;

    /*--------- IfElse ---------*/
    IfElse           -> IF! Operation Block ELSE! Block;

    /*--------- Block ---------*/
    Block            -> BLOCKSTART! Body BLOCKEND!
                      | BLOCKSTART! BLOCKEND!;

    /*--------- Operation ---------*/
    Operation        -> Operation PSIXOPERATOR OP6
                      | OP6;
    OP6              -> OP6 PFIVEOPERATOR OP5
                      | OP5^;
    OP5              -> PFOUROPERATOR OP5
                      | OP4^;
    OP4              -> OP4 PTHREEOPERATOR OP3
                      | OP3^;
    OP3              -> OP3 PTWOOPERATOR OP2
                      | OP2^;
    OP2              -> OP2 PONEOPERATOR OP1
                      | OP1^;
    OP1              -> Operand^
                      | OP1 PZEROOPERATOR Operand
                      | LPARENS! Operation^ RPARENS!;
    Operand	         -> Block^
                      | Integer^
            	      | Real^
                      | Boolean^
                      | Identifier^
                      | Literals^
                      | Invocation^;

    Boolean          -> BOOL;
    Integer          -> INT;
    Real             -> REAL;
    Identifier       -> IDENTIFIER
                      | IDENTIFIER Accessor;


    Literals         -> String^
                      | List^
                      | StructLiteral^
                      | Tuple^;

    String           -> STRING;

    StructLiteral    -> LPARENS! Field (SEMICOLON! Field)* RPARENS!;
    Field            -> Identifier ASSIGN! Operation; 

    Invocation       -> Identifier LPARENS! (Operation (COMMA! Operation)*)? RPARENS!;

    /*--------- Declaration ---------*/
    Declaration      -> Struct^
                      | Actor^
                      | Initialisation^
                      | Assignment^
                      | Function^
                      | Reassignment^;

    Struct           -> STRUCT! Identifier ASSIGN! BLOCKSTART! TypeDecls? BLOCKEND!;
    TypeDecls        -> TypeDecl SEMICOLON! TypeDecls
                      | TypeDecl^ SEMICOLON!;

    Actor            -> ACTOR! Identifier ASSIGN! Block;

    Assignment       -> (LET | VAR) Identifier ASSIGN! Operation;
    Initialisation   -> (LET | VAR) TypeDecl ASSIGN! Operation;

    Function         -> LET! Identifier LPARENS! Ids? RPARENS! COLON! Types ASSIGN! Operation;

    Ids              -> Identifier (COMMA! Identifier)*;
    TypeDecl         -> Identifier COLON! Types;

    /*--------- Reassignment ---------*/
    Reassignment     -> Identifier ASSIGN! Operation;

    /*-------- Type ---------*/
    Types            -> Type (LEADSTO! Type)*;
    Type             -> PrimitiveType^
                      | Identifier^
                      | ListType^
                      | TupleType^;

    TupleType        -> LPARENS! Types RPARENS!;
    ListType         -> STARTLIST! Types COMMA! INT ENDLIST!;
    PrimitiveType    -> PRIMITIVE;

    /*--------- List ---------*/
    List             -> STARTLIST! Lists (COMMA! Lists)* ENDLIST!;
    Lists            -> Operation TO^ Operation
					            | Operation^;
                                 
    /*--------- Tuple ---------*/
    Tuple            -> LPARENS! Operation (COMMA! Operation)+ RPARENS!;

    /*--------- Accessor ---------*/
    Accessor         -> DOT! Identifier^
                      | DOT! STARTLIST! Operation ENDLIST!;
  }
}
