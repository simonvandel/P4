grammar vSprogGrammar{

  options{
    Axiom         = "Program";
    Separator     = "SEPARATOR";
  }

  terminals{
    NEW_LINE      -> U+000D | U+000A | U+000D U+000A | U+2028 |  U+2029;
    WHITE_SPACE   -> U+0020 | U+0009 | U+000B | U+000C;
    COMMENT_LINE  -> '//' (.* - (.* NEW_LINE .*)) NEW_LINE;
    COMMENT_BLOCK -> '/*' (.* - (.* '*/' .*)) '*/';
    SEPARATOR     -> (NEW_LINE | WHITE_SPACE | COMMENT_LINE | COMMENT_BLOCK)+;
    LET           -> 'let';
    EQUALS        -> '=';
    VAR           -> 'var';
    ASSIGN        -> ':=';
    LPARENS       -> '(';
    RPARENS       -> ')';
    STARTTUPLE    -> '<';
    ENDTUPLE      -> '>';
    LEADSTO       -> '->';
    COLON         -> ':';
    BLOCKSTART    -> '{';
    BLOCKEND      -> '}';
    DOT           -> '.';
    SEMICOLON     -> ';';
    STRUCT        -> 'struct';
    PRIMITIVE     -> 'int' | 'real' | 'char' | 'bool' | STRING;
    INT           -> [1-9][0-9]* | '0';
    REAL          -> ([0-9]+'.'[0-9]+)|([0-9]+'.')|('.'([0-9])+);
    IDENTIFIER    -> [a-zA-Z_][a-zA-Z_0-9]*-(LET | VAR | PRIMITIVE | STRUCT);
    STARTLIST     -> '[';
    ENDLIST       -> ']';
    COMMA         -> ',';
    PZEROOPERATOR -> '*' | '/' | '%';
    PONEOPERATOR  -> '+' | '-';
    NUMBER        -> INT | REAL;
    STRING        -> '"'[a-zA-Z_0-9]*'"';
    CHAR          -> '\''[a-zA-Z_0-9]|' ''\'';
    TO            -> '..';
    WHILE         -> 'while';
    FOR           -> 'for';
  }

  rules{
    /*--------- Program ---------*/
    Program          -> StatementList^;
    StatementList    -> Statement SEMICOLON! StatementList
                      | Statement^ SEMICOLON!
                      | Statement^;

    /*--------- Statement ---------*/
    Statement        -> Declaration^
                      | Reassignment^
                      | ValueStatement^;

    /*--------- Declaration ---------*/
    Declaration      -> Struct
                      | Initialisation^
                      | TypeDecl;                                               // a:int || a:int->int ...
    Struct           -> STRUCT IDENTIFIER ASSIGN BLOCKSTART TypeDecls BLOCKEND; // struct a := {... Something ...}
    Initialisation   -> LET TypeID ASSIGN! ValueStatement
                      | VAR TypeID ASSIGN^ ValueStatement;
    TypeID           -> IDENTIFIER LPARENS! Ids? RPARENS! COLON! SimpleTypes
                                                              // let a(b,c):(int->real)->[int]->real := {... Something ...};
                      | IDENTIFIER LPARENS Ids? RPARENS                         // let a(a,c) := {... Something ...};
                                                                                // Context: "a:(int->real)->[int]->real;"
                      | TypeDecl^                                               // let a:int := 4;
                      | IDENTIFIER;                                             // let a := 4; // Context: "a:int;"
    Ids              -> IDENTIFIER COMMA Ids                                    // a,b,c,d ...
                      | IDENTIFIER;
    TypeDecls        -> TypeDecls SEMICOLON TypeDecl
                      | TypeDecl;
    TypeDecl         -> IDENTIFIER^ COLON! SimpleTypes;

    /*-------- SimpleType ---------*/
    SimpleTypes      -> SimpleTypes LEADSTO SimpleType
                      | SimpleType^;
    SimpleType       -> PRIMITIVE^
                      | IDENTIFIER
                      | STARTLIST PRIMITIVE ENDLIST
                      | LPARENS SimpleTypes RPARENS;

    /*--------- ValueStatement ---------*/
    ValueStatement   -> List
                      | Tuple
                      | Block
                      | Expression^;

    /*--------- List ---------*/
    List             -> STARTLIST Expression TO Expression ENDLIST             // [3+4..30*2]
                      | STARTLIST Expressions ENDLIST;                         // [Peter,Michael,Tim,Gitte] || [{let a:[int]
                                                                              //:= [1..100]; a.Remove([50..60])}]                        // == [1..49,61..10]

    /*--------- Block ---------*/
    Block            -> BLOCKSTART! StatementList BLOCKEND!;

    /*--------- Tuple ---------*/
    Tuple            -> LPARENS Expression COMMA Expressions RPARENS;          // (1,Tim,"Yvonne")

    /*--------- Expression ---------*/
    Expressions      -> Expression COMMA Expressions
                      | Expression;
    Expression       -> Expression PONEOPERATOR^ Factor
                      | Factor^;
    Factor           -> Factor PZEROOPERATOR^ Term
                      | Term^;
    Term             -> Block^
                      | IDENTIFIER^
                      | NUMBER^
                      | LPARENS! Expression^ RPARENS!;


    /*--------- Reassignment ---------*/
    Reassignment     -> IDENTIFIER ASSIGN ValueStatement                    // a := 5;
                      | Accessor ASSIGN ValueStatement;

    /*--------- Accessor ---------*/

    Accessor         -> IDENTIFIER DOT IDENTIFIER
                      | DOT STARTLIST NUMBER ENDLIST;

    /*--------- ForLoop ---------*/
    //ForLoop          -> FOR LPARENS 'blabla' SEMICOLON expression SEMICOLON expression RPARENS ASSIGN Block
    //ForLoop          ->
  }
}
