grammar vSprogGrammar{

  options{
    Axiom         = "Program";
    Separator     = "SEPARATOR";
  }

  terminals{
    NEW_LINE      -> U+000D | U+000A | U+000D U+000A | U+2028 |  U+2029;
    WHITE_SPACE   -> U+0020 | U+0009 | U+000B | U+000C;
    COMMENT_LINE  -> '//' (.* - (.* NEW_LINE .*)) NEW_LINE?;
    COMMENT_BLOCK -> '/*' (.* - (.* '*/' .*)) '*/';
    SEPARATOR     -> (NEW_LINE | WHITE_SPACE| COMMENT_LINE | COMMENT_BLOCK)+;

    /*--------- Keywords ---------*/
    LET           -> 'let';
    WAIT          -> 'wait';
    ACTOR         -> 'actor';
    RECEIVE       -> 'receive';
    SEND          -> 'send';
    SPAWN         -> 'spawn';
    VAR           -> 'var';
    WHILE         -> 'while';
    FOR           -> 'for';
    KILL          -> 'kill';
    ME            -> 'me';
    IN            -> 'in';
    IF            -> 'if';
    ELSE          -> 'else';
    STRUCT        -> 'struct';
    RETURN        -> 'return';
    PRIMITIVE     -> 'void' | 'int' | 'real' | 'char' | 'bool';

    IDENTIFIER    -> [a-zA-Z_][a-zA-Z_0-9]*-(LET | VAR | PRIMITIVE | STRUCT | ACTOR | RECEIVE | SEND | SPAWN | WAIT | RETURN | FOR | IN | IF | ELSE | WHILE | KILL | ME);

    /*--------- Symbols ---------*/
    ASSIGN        -> ':=';
    LPARENS       -> '(';
    RPARENS       -> ')';
    STARTTUPLE    -> '<';
    ENDTUPLE      -> '>';
    LEADSTO       -> '->';
    COLON         -> ':';
    BLOCKSTART    -> '{';
    BLOCKEND      -> '}';
    TO            -> '..';
    DOT           -> '.';
    SEMICOLON     -> ';';
    STARTLIST     -> '[';
    ENDLIST       -> ']';
    COMMA         -> ',';

    PZEROOPERATOR -> '^' | '#';
    PONEOPERATOR -> '*' | '/' | '%';
    PTWOOPERATOR  -> '+' | '-';
    PTHREEOPERATOR  -> '=' | '!=' | '<' | '<=' | '>' | '>=';
    PFOUROPERATOR  -> 'NOT';
    PFIVEOPERATOR  -> 'AND' | 'NAND';
    PSIXOPERATOR  -> 'OR' | 'XOR' | 'NOR' ;

    /*--------- Numbers ---------*/
    INT           -> '-'?[1-9][0-9]* | '0'; 
    REAL          -> ([0-9]+'.'[0-9]+)|([0-9]+'.')|('.'([0-9])+); 

    BOOL          -> 'true' | 'false';

    /*--------- Chars ---------*/
    STRING        -> '"'[a-zA-Z_0-9 !]*'"';
    CHAR          -> '\''[a-zA-Z_0-9 ]|' ''\'';
  }

  rules{
    /*--------- Program ---------*/
    Program          -> Body;

    Body             -> Body^ SEMICOLON! Expression
                      | Body^ SEMICOLON!
                      | Expression;

    /*--------- Expression ---------*/
    Expression       -> Declaration^
                      | Operation^
                      | Receive^
                      | Kill^
                      | Spawn^
                      | Return^
                      | Send^
                      | If^
                      | IfElse^
                      | While^
                      | ForIn^;

    Spawn            -> (LET | VAR) TypeDecl ASSIGN! SPAWN! Identifier Operation?;

    Send	           -> SEND! Identifier Operation;

    /*--------- Return ---------*/
    Return           -> RETURN! Operation;

    /*--------- Receive ---------*/
    Receive          -> RECEIVE! TypeDecl ASSIGN! Block;

    /*--------- Kill ---------*/
    Kill             -> KILL! Operation;

    /*--------- Me ---------*/
    Me             -> ME;

    /*--------- For ---------*/
    ForIn            -> FOR! Ids IN! (ListRange | Identifier ) Block;

    /*--------- While ------*/
    While            -> WHILE! Operation Block;

    /*--------- If ---------*/
    If               -> IF! Operation Block;

    /*--------- Ifelse ---------*/
    IfElse           -> IF! Operation Block ELSE! Block;

    /*--------- Block ---------*/
    Block            -> BLOCKSTART! Body BLOCKEND!
                      | BLOCKSTART! BLOCKEND!;

    /*--------- Operation ---------*/
    Operation        -> Operation PSIXOPERATOR OP6
                      | OP6;
    OP6           -> OP6 PFIVEOPERATOR OP5
                      | OP5^;
    OP5           -> PFOUROPERATOR OP5
                      | OP4^;
    OP4           -> OP4 PTHREEOPERATOR OP3
                      | OP3^;
    OP3           -> OP3 PTWOOPERATOR OP2
                      | OP2^;
    OP2           -> OP2 PONEOPERATOR OP1
                      | OP1^;
    OP1             -> Operand^
                      | OP1 PZEROOPERATOR Operand
                      | LPARENS! Operation^ RPARENS!;
    Operand	         -> Block^
                      | Integer^
            	        | Real^
                      | Boolean^
                      | Me^
                      | Identifier^
                      | IdentifierAccessor^
                      | Literals^
                      | Invocation^;

    Boolean          -> BOOL;
    Integer          -> INT;
    Real             -> REAL;
    Identifier       -> IDENTIFIER;


    Literals         -> String^
                      | ListRange^
                      | StructLiteral^
                      | Tuple^;

    String           -> STRING;

    StructLiteral    -> LPARENS! Field (SEMICOLON! Field)* RPARENS!;
    Field            -> Identifier ASSIGN! Operation; 

    Invocation       -> Identifier LPARENS! Operations? RPARENS!;

    /*--------- Declaration ---------*/
    Declaration      -> Struct^
                      | Actor^
                      | Initialisation^
                      | Assignment^
                      | Function^
                      | Reassignment^;

    Struct           -> STRUCT! Identifier ASSIGN! BLOCKSTART! TypeDecls? BLOCKEND!;
    TypeDecls        -> //TypeDecls SEMICOLON! TypeDecl SEMICOLON!
                      TypeDecl SEMICOLON! TypeDecls
                      | TypeDecl^ SEMICOLON!;

    Actor            -> ACTOR! Identifier ASSIGN! Block;

    Assignment       -> (LET | VAR) Identifier ASSIGN! Operation;
    Initialisation   -> (LET | VAR) TypeDecl ASSIGN! Operation;

    Function         -> LET! Identifier LPARENS! Ids? RPARENS! COLON! Types ASSIGN! Operation;

    Ids              -> Identifier (COMMA! Identifier)*;
    TypeDecl         -> Identifier COLON! Types;

    /*--------- Reassignment ---------*/
    Reassignment       -> (Identifier | IdentifierAccessor) ASSIGN! Operation;

    IdentifierAccessor -> Identifier^ Accessor;

    /*-------- Type ---------*/
    Types            -> Type (LEADSTO! Type)*;
    Type             -> PrimitiveType^
                      | Identifier^
                      | ListType^
                      | TupleType^;

    TupleType        -> LPARENS! Types RPARENS!;
    ListType         -> STARTLIST! Types ENDLIST!;
    PrimitiveType    -> PRIMITIVE;

    /*--------- List ---------*/
    ListRange        -> STARTLIST! ListParams ENDLIST!;
    ListParams       ->	ListParams COMMA! Operation
                      | Operation TO! Operation
                      | Operation;

    /*--------- Tuple ---------*/
    Tuple            -> LPARENS! Operations COMMA! Operation RPARENS!;
    Operations       -> Operations COMMA! Operation
                      | Operation;

    /*--------- Accessor ---------*/
    Accessor         -> DOT! Identifier^
                      | DOT! Identifier^ Accessor
                      | DOT! STARTLIST! INT ENDLIST!
                      | DOT! STARTLIST! INT ENDLIST! Accessor;
  }
}
